\documentclass[
    iai, % Saisir le nom de l'institut rattaché
    il, % Saisir le nom de l'orientation
    %confidential, % Décommentez si le travail est confidentiel
]{heig-tb}

\usepackage[nooldvoltagedirection,european,americaninductors]{circuitikz}

\signature{signature_alec_berney.svg}

\makenomenclature
\makenoidxglossaries
\makeindex

\addbibresource{bibliography.bib}

\input{nomenclature}
\input{acronyms}
\input{glossary}
\input{meta}

\surroundwithmdframed{minted}

%% Début du document
\begin{document}
\selectlanguage{french}
\maketitle
\frontmatter
\clearemptydoublepage

%% Requis par les dispositions générales des travaux de Bachelor
\preamble
\authentification

%% Résumé / Version abbrégée
\begin{abstract}
    \input{abstract}
\end{abstract}

%% Sommaire et tables
\clearemptydoublepage
{
    \tableofcontents
    \let\cleardoublepage\clearpage
    \listoffigures
    \let\cleardoublepage\clearpage
    \listoftables
    \let\cleardoublepage\clearpage
    \listoflistings
}

\printnomenclature
\clearemptydoublepage
\pagenumbering{arabic}

%% Contenu
\mainmatter

\chapter{Introduction}
L'introduction est une section requise dans un rapport technique. Introduisez votre travail, l'idée de départ et les objectifs attendus. Un lecteur qui découvrirait votre projet au travers de cette introduction devrait ainsi être capable d'en comprendre le cadre, l'idée générale et les aboutissants du projet.

\section{Contexte}
Le FabLab est un laboratoire permettant de réaliser des travaux sur des machines de ce dernier. Actuellement, pour réaliser un travail sur une machine, il est nécessaire de réaliser une demande par email à l’un des techniciens ayant le droit d’usiner sur la machine souhaitée. Une fois la demande reçue, le technicien usine dès qu’il le peut et doit recontacter le mandataire pour lui donner son travail fini. Durant toute cette période, aucun retour n’a été donné au mandataire. En cas de problème avec un travail, le technicien doit également recontacter le client.
Certains défauts majeurs peuvent être identifier avec la procédure actuelle, les voici :
\begin{itemize}
    \item Il n’y a aucun suivi des travaux pour le mandataire, \cite{lieberherr}
    \item Les échanges liés aux travaux peuvent être réalisé via plusieurs canaux (email, Teams, vocal, etc.), \cite{lieberherr}
    \item Risque de désorganisation, \cite{lieberherr}
    \item Manque de clarté quant à la procédure, \cite{lieberherr}
    \item Aucun historique des travaux réalisé,
    \item Gestion problèmes survenus lors du travail compliqué.
\end{itemize}
Une première partie du projet a déjà été réalisée lors du travail de Bachelor de monsieur Tristan Lieberherr. De ce fait aucun cahier des charges n’était défini à l’origine, car il était d’abord nécessaire d’effectuer une analyse du projet afin de définir les points d’améliorations qu’allaient contenir le cahier des charges.


\section{Cahier des Charges}

\subsection{Prologue}

Le projet étant déjà existant, aucun cahier des charges n'était défini à
l'origine. En effet, il était d'abord nécessaire de réaliser une analyse
du projet afin de définir les points d'améliorations qu'allaient
contenir le cahier des charges.

\subsection{Objectifs}

Les objectifs principaux du projet sont les suivants:
\begin{itemize}
    \item Mettre en place une infrastructure de développement professionnel,
    \item Mettre en place les DevOps pour le projet existant,
    \item Améliorer la conception de la base de données en ajoutant des données précieuses,
    \item Améliorer le backend du projet existant.
\end{itemize}

Nous allons maintenant passer à la liste des tâches qui devront être
effectuées durant le travail de bachelor.

Pour les toutes les tâches qui seront listés plus bas, un code couleur a
été établi pour définir le niveau de besoin de ces dernières, le voici:

\begin{itemize}
    \item Vert = doit être réaliser (MVP = Minimum Valuable Product),
    \item Orange = serait réaliser dans l'idéal,
    \item Rouge = pourrait potentiellement être réaliser.
\end{itemize}

Je m'engage à réaliser les tâches suivantes :

\begin{table}[h]
    \begin{center}
        \caption{Liste des tâches / exigences à réaliser durant le projet \label{taches}}
        \begin{tabular}{c|l|r}
            #   & Tâche / Exigence                                                                                                       & Priorité      \\ \hline
            1   & Créer une infrastructure de développement professionnel                                                                & Obligatoire   \\
            2   & Mettre en place un pipeline DevOps complet en passant par les étapes suivantes                                         & Obligatoire   \\
            2.a & Mettre en place un outil d’intégration continue (CI)                                                                   & Obligatoire   \\
            2.b & Mettre en place un outil / pipeline de déploiement continue (CD)                                                       & Obligatoire   \\
            2.c & Mettre en place une infrastructure de production accueillant le rendu du projet                                        & Obligatoire   \\
            3   & Mettre à jour le projet existant vers les nouvelles versions des technologies utilisées                                & Obligatoire   \\
            3.a & Mettre à jour le frontend existant vers les nouvelles versions des technologies utilisées                              & Obligatoire   \\
            3.b & Mettre à jour le backend existant vers les nouvelles versions des technologies utilisées                               & Obligatoire   \\
            4   & Reconcevoir la base de données pour qu’elle prenne en compte certains points supplémentaires                           & Obligatoire   \\
            4.a & La base de données doit prendre en compte les rôles des utilisateurs                                                   & Obligatoire   \\
            4.b & La base de données doit prendre en compte les ressources liées aux machines industrielles utilisées dans l’application & Obligatoire   \\
            5   & Améliorer le backend du projet                                                                                         &               \\
            5.a & Appliquer les standards de programmation web (REST)                                                                    & Obligatoire   \\
            5.b & Mettre en place une architecture de code cohérente                                                                     & Obligatoire   \\
            5.c & Mettre en place une vérification des entrées utilisateurs                                                              & Obligatoire   \\
            5.d & Mettre en place l’authentification de l’utilisateur                                                                    & Obligatoire   \\
            5.e & L’ajout des rôles des utilisateurs                                                                                     & Obligatoire   \\
            5.f & Ajouter la gestion des ressources liées aux machines industrielles utilisées dans l’application                        & Intermédiaire \\
            5.g & Améliorer le système de notifications pour le rendre plus sécurisé                                                     & Basse         \\
            6   & Améliorer le frontend afin d’intégrer toutes les fonctionnalités du backend                                            &               \\
            6.a & Mettre à jour le frontend pour coller aux modifications des routes du backend / de l'api                               & Obligatoire   \\
            6.b & Ajouter la gestion des ressources liées aux machines industrielles utilisées dans l’application                        & Intermédiaire \\
            6.c & Améliorer le système de notifications pour le rendre plus sécurisé                                                     & Basse         \\
            7   & Tester l’application à l’aide de tests automatisés                                                                     & Obligatoire   \\
            7.a & Réaliser des tests unitaires automatisés                                                                               & Obligatoire   \\
            7.b & Réaliser des tests d’intégration automatisés                                                                           & Obligatoire   \\
        \end{tabular}
    \end{center}
\end{table}

\subsection{Déroulement global projet}

Le projet se réalise durant le semestre de printemps. Le semestre possède 14 semaines de travail de 1 jour et demi de travail si on exclut la semaine du CRUNCH et celle des vacances.
Il y a ensuite 6 semaines à temps pleins pour finaliser le travail de Bachelor.

Une séance hebdomadaire est prévue avec le professeur responsable du travail, m. Chevallier.

Le projet est réparti en 3 principales phases, qui s'effectueront dans l'ordre suivant:
\begin{enumerate}
    \def\labelenumi{\arabic{enumi}.}
    \item L'analyse du projet:
          \begin{enumerate}
              \def\labelenumii{\alph{enumii}.}
              \item L'étude du projet et de ses technologies,
              \item Les choix technologiques et conceptuels.
          \end{enumerate}
    \item La conception et réalisation du projet, contenant principalement:
          \begin{enumerate}
              \def\labelenumii{\alph{enumii}.}
              \item La mise en place des environnements de développement et de production,
              \item La réalisation des DevOps,
              \item L'amélioration du Backend et de la base de données,
              \item La modification du Frontend.
          \end{enumerate}
    \item La préparation des livrables.
\end{enumerate}

La première phase d'analyse a pour objectif de définir tout le cadre théorique du projet et les divers choix à réaliser tout au long de ce dernier.
Cette phase devrait se terminer à la fin de la semaine numéro 7 ou 8.
Tout en sachant que cette phase contient l'écriture du cahier des charges et que ce dernier doit être rendu au plus tard 6 semaines après le début du travail de bachelor, c'est-à-dire, le 10.04.2022.

La seconde phase, concernant la conception et la réalisation du projet est la plus conséquente.
Cette dernière suivra la première et devrait se terminer lors de la 20ème semaine si tout se déroule comme prévu.

La dernière phase, concernant la préparation des livrables, est une phase importante qui se réalisera tout au long du projet et se terminera la dernière semaine du travail de bachelor.

Un rendu intermédiaire est également prévu après 150 heures de travail et possède comme date le 11.05.2022.

\subsection{Résultats attendus}

Les résultats attendus pour ce projet dépendent énormément des tâches établies définies dans la partie Objectif de ce document.
En effet, chaque tâche définie est vérifiable et sera donc utilisée pour évaluer le résultat du projet.
\clearpage

\chapter{Analyse}

\section{Choix technologiques}

Dans cette section, je vais énumérer tous les choix technologiques ou conceptuels liés au projet.
Mais avant cela, il est nécessaire de définir précisément les besoins pour le projet afin de réaliser des choix cohérents en fonction de ces derniers.
Pour chaque choix, technologiques ou conceptuels, une liste des possibilités réalisables sera énumérée et si possible représentée visuellement.
Cette liste de possibilités sera accompagnées des avantages et inconvénients de chaque solution en s'inspirant des besoins du projet.

\subsection{Rappel des choix technologiques déjà effectués}
Dans cette section, je vais énumérer les choix technologiques déjà effectués par le premier étudiant ayant travaillé sur le projet.
Considérant les choix de l'étudiant comme bon et bien argumenté, je ne vois aucune raison de les remettre en question, surtout qu'un travail conséquent a déjà été réalisé avec les technologies choisies. Pour plus de précisions sur ces choix technologiques, je vous invite à consulter son \href{TODO}{rapport}.
Voici un résumé des décisions prises lors de la première phase du projet:
\begin{itemize}
    \item Backend: PHP avec le framework Laravel,
    \item Frontend: Javascript avec Vue.js,
    \item SGBD: MySQL,
    \item Outil SSO: Shibboleth. %https://blog.miniorange.com/what-is-shibboleth/
\end{itemize}

%TODO: ajouter image stackshare.

\subsection{Besoins pour le projet}
Je vais ici définir les besoins du projet et ceci en les séparant par parties distinctes.

\subsubsection{Besoins pour l'infrastructure de développement}
Pour commencer, définissons l'infrastructure de développement.
L'infrastructure de développement englobe tous les outils à installer et toutes les configurations à réaliser sur un pc vierge afin que le développeur puisse commencer à développer l'application.
En général, ce qui est recherché, c'est la simplicité et la rapidité de configuration de cet environnement.
Dans notre cas, pour que le développeur puisse commencer à développer, il doit principalement mettre en place les outils suivants:
\begin{itemize}
    \item un IDE (Integrated Development Environment), de préférence Visual Studio Code,
    \item l'outil de versioning git,
    \item un SGBD (Système de Gestion de Base de Données), %\cite{}
    \item le language PHP,
    \item l'outil Composer,
    \item le framework Laravel,
    \item l'environement d'exécution (runtime environment) Node.js,
    \item le framework Vue.js.
\end{itemize}
Comme vous pouvez le voir, la liste devient vite longue et certains des outils à installer prennent passablement de temps et possèdent des configuration spécifiques.
Je parle notamment des outils suivants:
\begin{itemize}
    \item le SGBD (Système de Gestion de Base de Données),
    \item le language PHP, avec Composer et le framework Laravel,
    \item l'environement d'exécution (runtime environment) Node.js et le framework Vue.js.
\end{itemize}
Ces outils n'étant pas triviaux à mettre en place et changeant pour chaque projet, il est préférable de simplifier le plus possible leur installation et configuration.

Comme vous l'aurez compris, un des besoins le plus important pour le choix de cette infrastructure, est la simplicité de mise en place du projet.
Il faut que cela soit facile à prendre en main et bien documenté.
Un des autres points à prendre en compte, est la disponibilité des outils utilisés, dans le sens où des outils payants ne pourraient pas être accessibles pour certains développeur.
Créer quelque chose de simple à prendre en main, c'est important, mais il faut aussi prendre en compte la difficulté nécessaire pour fournir les outils fini simplifiant cett étape.
% gros avantage, CI gratuit si on a tout gratuit à ajouter

\subsubsection{Besoins pour l'infrastructure de production}
Nous allons maintenant faire de même pour l'infrastructure de production.
L'infrastructure de production englobe tous les outils à installer et toutes les configurations à réaliser sur un pc vierge afin que le programme final soit accessible est utilisable par n'importe quel utilisateur.
En général, la simplicité de mise à jour du programme, la performance et la robustesse sont recherchés.
On peut aussi prendre en compte la flexibilité de la solution, dans le sens où il serait facile de déployer le programme final sur une autre machine de production.
En effet, la première étape de configuration se réalise peu de fois et si cette dernière est un peu plus compliquée, cela n'est pas forcément un énorme désavantage.
Dans notre cas, pour que le programme puisse fonctionner sur le serveur de production, il est nécessaire d'installer tous les outils suivants:
\begin{itemize}
    \item potentiellement l'outil de versioning git,
    \item un SGBD (Système de Gestion de Base de Données),
    \item le language PHP,
    \item l'outil Composer,
    \item le framework Laravel,
    \item Un serveur Apache,
    \item Un proxy.
\end{itemize}
La liste des outils à installer et configurer, comme pour l'environnement de développement, est conséquente.
Certains outils prennent passablement de temps et possèdent des configuration spécifique.
Je parle notamment des outils suivants:
\begin{itemize}
    \item le SGBD (Système de Gestion de Base de Données),
    \item le language PHP, avec Composer et le framework Laravel.
\end{itemize}
Comme expliqué précédemment, une certaine flexibilité et simplicité est recherchée lors de la mise en place de l'infrastructure et c'est pour cela qu'il est préférable de simplifier le plus possible l'installation et la configuration des outils cités ci-dessus..

Si nous résumons les critères qui influenceront notre décision, nous pouvons ressortir ces derniers:
\begin{itemize}
    \item la performance de l'infrastructure,
    \item la simplicité de mise à jour du programme au sein de l'infrastructure,
    \item la robustesse de l'infrastructure,
    \item la flexibilité de l'infrastructure.
\end{itemize}

\subsubsection{Besoins pour les \Gls{devops}}
Pour finir, nous allons maintenant faire de même pour le pipeline \Gls{devops}.
Le pipeline \Gls{devops} défini toutes les étapes réalisées et les outils utilisé pour parvenir à mettre en place une infrastructure de travail et de livraison de produit fonctionnel et automatisée au maximum.
Le but des \Gls{devops} étant d'automatisé le plus de tâches possibles, on attend du donc du pipeline les critères suivants:
\begin{itemize}
    \item la performance de l'infrastructure (dans le sens de la rapidité),
    \item la "simplicité" de mise en place du pipeline,
    \item la simplicité de mise à jour du pipeline via une flexibilité maximum,
    \item la robustesse du pipeline,
    \item la possibilité d'ajouter des étapes intermédiaires de tests du produit entre l'infrastructure de développement et de prodution.
\end{itemize}

La flexibilité et simplicité ressort encore une fois dans les besoins de cette section.
Mais un point important est la possibilité de tester manuellement son produit avant de le livrer en production.

% docker
\subsection{Introduction à \Gls{docker}}
Pour pour pouvoir comparer les différentes infrastructures et faire des choix sur ces dernière, il est important d'introduire l'outil \Gls{docker}.
\Gls{docker} est un outil permettant de gérer des containers.
Qu'est-ce qu'un container? Un container est une sorte de machine virtuelle plus légère ayant pour but d'encapsuler une ou plusieurs applications / outils technologiques ainsi que toutes les dépendances que ces applications exigent pour leur bon fonctionnement.
Il ne s'agit donc pas de virtualisation mais de "conteneurisation" ou "containerization" en anglais.
Dans une "conteneurisation", seul l'OS et le software est virtualisé et non le hardware.
Nous remarquons bien la différence avec la figure suivante:
\begin{figure}
    %\href{https://www.docker.com/wp-content/uploads/2021/11/docker-containerized-and-vm-transparent-bg.png}
    %{\includegraphics[width=\textwidth]{picture}}
    \caption{Comparaison entre conteneurs et machines virtuelles}
\end{figure}
Les containers sont facilement téléchargeables et transmissibles. Ils sont également relativement facile à mettre en place.
Le principe est simple, nous avons une application et une certaine configuration qui fonctionne, nous pouvons facilement l'encapsuler dans un container et le transmettre à nos collègues ou le télécharger sur un autre pc.
Un des principales avantages, est le fait que le container ne dépend pas de l'OS ou de l'état de la machine sur lequel il va être lancé.
Le seul point requis, est de posséder docker sur la machine.
Cette solution rend plus flexible et portable l'exécution d'application sur n'importe quelle machine.
Voici un schéma démontrant la façon dont docker et des containers dockers sont mis en place sur une machine:
\begin{figure}
    %\href{https://www.docker.com/wp-content/uploads/2021/11/container-what-is-container.png}
    %{\includegraphics[width=\textwidth]{picture}}
    \caption{Conteneurisation d'applications}
\end{figure}
%https://www.docker.com/resources/what-container/
%https://www.ibm.com/fr-fr/cloud/learn/docker
%https://fr.wikipedia.org/wiki/Docker_(logiciel)
%https://www.youtube.com/watch?v=Gjnup-PuquQ

Voici une liste des avantages généraux de Docker comparé à une VM:
\begin{itemize}
    \item Les containers sont petits comparé au VM, \cite{koukia}
    \item Les containers utilisent moins de ressources, \cite{koukia}
    \item Les containers démarrent plus rapidement, \cite{koukia}
    \item Fonctionne bien avec les DevOps et les CI/CD, \cite{koukia,data-flair_pros_cons,data-flair_use_cases}
    \item facilite l'extensibilité horizontale. \cite{data-flair_use_cases}
\end{itemize}

Voici une liste des inconvénients de Docker comparé à une VM:
\begin{itemize}
    \item La sécurité, \cite{koukia}
    \item L'isolation non complète', \cite{koukia}
    \item La gestion du réseau. \cite{koukia}
\end{itemize}

% Packaging software in a way that leverages the skills developers already have. \cite{kane2018docker}
% Bundling application software and required OS filesystems together in a single standar‐dized image format. \cite{kane2018docker}
% Using packaged artifacts to test and deliver the exact same artifact to all systems in all environments. \cite{kane2018docker}
% Abstracting software applications from the hardware without sacrificing resources \cite{kane2018docker}

% TODO ajouter image docker use cases
\begin{figure}
    %\href{https://data-flair.training/blogs/wp-content/uploads/sites/2/2018/10/Docker-Use-Cases-01.jpg}
    %{\includegraphics[width=\textwidth]{picture}}
    \caption{Comparaison entre conteneurs et machines virtuelles}
\end{figure}

% quand ne pas utiliser docker: Performance is critical to your application

%virtual machine vs containers: 
%https://www.youtube.com/watch?v=cjXI-yxqGTI
%https://www.ibm.com/cloud/learn/containers?utm_medium=OSocial&utm_source=Youtube&utm_content=000023UA&utm_term=10010608&utm_id=YTDescription-101-Containers-vs-VMs-LH-Containers-Guide&cm_mmc=OSocial_Youtube-_-Cloud+and+Data+Platform_SFT+Cloud+Platform+Digital-_-WW_WW-_-YTDescription-101-Containers-vs-VMs-LH-Containers-Guide&cm_mmca1=000023UA&cm_mmca2=10010608
%https://www.ibm.com/cloud/learn/virtual-machines?utm_medium=OSocial&utm_source=Youtube&utm_content=000005UJ&utm_term=10002434&utm_id=YTDescription-101-Containers-vs-VMs-LH-Virtual-Machines-Guide&cm_mmc=OSocial_Youtube-_-Cloud+and+Data+Platform_PLT+Cloud+Platform+F2F-_-WW_WW-_-YTDescription-101-Containers-vs-VMs-LH-Virtual-Machines-Guide&cm_mmca1=000005UJ&cm_mmca2=10002434


\subsubsection{Performances de \Gls{docker}}
\Gls{docker} est outil qui paraît très pratique, mais qu'en est-il de ses performances?
Pour ceci, nous allons retracer quelques évalutations réalisées lors d'une étude de IBM \cite{felter2015updated}. Nous allons parcourir ces évalutations via des graphiques, tiré de l'étude, résumants bien les résultats.
Commençant par la latence que peut apporter \Gls{docker}:
%copier coller et dans la légende, source: x ou tiré de: x
%todo ajouter figure
\begin{figure}
    %\href{https://www.docker.com/wp-content/uploads/2021/11/container-what-is-container.png}
    %{\includegraphics[width=\textwidth]{picture}}
    \caption{Network round-trip latency (µs), \cite{rad2017introduction}}
\end{figure}

On constate que la latence double, mais nous parlons ici de microsecondes, et de 30 microsecondes supplémentaires, ce qui est en soit assez peu pour de petite infrastructure.

%todo autres stats

%docker en prod perf:
%https://stackoverflow.com/questions/21691540/how-to-optimize-performance-for-a-docker-container/21707838#21707838
%https://stackoverflow.com/questions/21889053/what-is-the-runtime-performance-cost-of-a-docker-container
%https://dominoweb.draco.res.ibm.com/reports/rc25482.pdf
%https://www.freecodecamp.org/news/7-cases-when-not-to-use-docker/


\subsubsection{Et \Gls{kubernetes}?}
Pourquoi utiliserions-nous forcément \Gls{docker} sans avoir réfléchi à la possibilité de \Gls{kubernetes}?
Pour commencer, comme indiquer sur le site officiel:
"Kubernetes est un système open-source permettant d'automatiser le déploiement, la mise à l'échelle et la gestion des applications conteneurisées".
\Gls{kubernetes} n'est donc pas vraiment une alternative à \Gls{docker}, mais peut être plutôt utiliser comme complément à ce dernier.
Comme la partie principale de \Gls{kubernetes} est de gérer les applications conteneurisées et de simplifier le load balancing, par exemple, il n'est pas forcément utile pour nous d'approfondir les recherches sur le sujet.
En effet, La charge attendu par l'application déployée ne devrait pas dépasser les 100 utilisateurs simultanés. La question du load-balancing est donc écartée, tout comme la mise en place d'un cluster \Gls{kubernetes}.

% comment mettre en place -> voir avec monsieur Graf / regarder avec des profs
% si question pointu, peuvent être transférer à m. chevallier

%https://kubernetes.io/
%https://www.youtube.com/watch?v=PziYflu8cB8
%docker vs k8s, IBM: https://www.youtube.com/watch?v=2vMEQ5zs1ko
%https://www.ibm.com/cloud/learn/kubernetes?cm_mmc=OSocial_Youtube-_-Hybrid+Cloud_Cloud+Platform+Digital-_-WW_WW-_-KubevsDockerYTDescription&cm_mmca1=000023UA&cm_mmca2=10010608#toc-what-is-ku-nVcfWlWE

%https://stackshare.io/: outil très utile pour faire des comparaisons de technologies

\subsubsection{Autres solutions de containers}
Pourquoi utiliserions-nous forcément \Gls{docker}
-> beaucoup moins utilisé

\begin{itemize}
    \item BSD Jails, %https://fr.wikipedia.org/wiki/BSD_Jail
    \item LXD, %https://linuxcontainers.org/lxd/
    \item LXC, %https://linuxcontainers.org/lxc/introduction/
    \item Solaris Zones, %https://docs.oracle.com/cd/E18440_01/doc.111/e18415/chapter_zones.htm#OPCUG426
    \item RKT. %https://www.redhat.com/en/topics/containers/what-is-rkt
\end{itemize}

% dev
\subsection{Infrastructures de développement}

\subsubsection{Présentation des infrastructures de développement \Gls{devops} possibles}
L'infrastructure que vous pouvez voir dans la figure ci-dessous et celle qui était utilisée lorsque j'ai reprise le projet.
En résumé, tous les outils ont été installés nativement sur la machine de développement sans virtualisation.
\figi{infrastructure_dev_actuelle.xml}{16cm}{Infrastructure de développement actuelle}
%\figi{infrastructure_dev_actuelle}{16cm}{Infrastructure de développement actuelle}
%\fig{infrastructure_dev_actuelle.xml}{Infrastructure de développement actuelle}

\figi{infrastructure_dev_db_docker.xml}{16cm}{Infrastructure de développement avec une db end docker}
%\fig{infrastructure_dev_db_docker}{Infrastructure de développement avec une db end docker}
%\fig{infrastructure_dev_db_docker.xml}{Infrastructure de développement avec une db end docker}

\figi{infrastructure_dev_db_laravel_docker.xml}{16cm}{Infrastructure de développement avec une db et Laravel en docker}
%\fig{infrastructure_dev_db_laravel_docker.xml}{Infrastructure de développement avec une db et laravel en docker}

Laravel \href{https://laravel.com/docs/9.x/homestead}{Homestead} est un environnement de développement virtualisé à l'aide d'une machine virtuelle \href{https://www.vagrantup.com/}{Vagrant}.
Cette solution est considérée comme le prédecesseur à Laravel Sail qui est beaucoup plus léger.
C'est pourquoi, cette solution ne fera pas parti des choix que nous allons argumenter, mais est présentée comme complément.
\figi{infrastructure_dev_db_laravel_homestead.xml}{16cm}{Infrastructure de développement avec Laravel Homestead}

\figi{infrastructure_dev_db_laravel_vuejs_docker.xml}{16cm}{Infrastructure de développement avec une db, Laravel et Vue.js en docker}

%https://laravel.com/docs/9.x/sail
%https://blog.logrocket.com/laravel-and-docker-a-guide-to-using-laravel-sail/
%https://r00t4bl3.com/post/how-to-setup-docker-environment-for-laravel-development
%https://dockerize.io/guides/php-laravel-guide
%https://www.honeybadger.io/blog/laravel-docker-php/

\subsubsection{Comparaison des infrastructures de développement \Gls{devops} possibles}
Les différentes infrastructures désormais présentées, il est nécessaire de les comparer en listant les pour et les contres de chaque changement en prenant comme référentielle l'infrastructure actuelle.
Les 3 améliorations (combinées ou non) proposées sont les suivantes:
\begin{itemize}
    \item Passage du SGBD en machine Docker,
    \item Passage du projet Laravel (et toutes ces technologies) en machine Docker,
    \item Passage du projet Vue.js (et toutes ces technologies) en machine Docker.
\end{itemize}

%\begin{multicols}{2}
%[

% vraiment bien se blinder au niveau des arguments via blog et études, sources écrites
% si on a pas trouvé, on peut dire je ne sais pas, on DOIT dire -> joker ultime
% toucher quelque chose en surface, si je ne connais pas, si point essentiel dans projet, faire un choix + essai -> prototype, démonstration sur expérience
% aussi parlé des charges qui devront être supportées et si c'est possible, nb user final par ex

Commençons par réfléchir sur le passage du SGBD en machine Docker.
Pour ceci, nous allons énumérer les avantages et inconvénients d'installer le SGBD nativement.
Avantages:
\begin{itemize}
    \item Gestion de la BD plus facile car le SGB est installé nativement,
    \item Le SGBD peut-être déjà installé et peut être utilisée directement,
    \item Ne nécessite pas Docker.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Demande du temps pour l'installation,
    \item Configuration à réaliser à la main,
    \item Fort risque d'erreur lors de la configuration,
    \item Installation différente pour chaque OS.
\end{itemize}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir le SGBD en machine Docker.
Avantages:
\begin{itemize}
    \item Accélère l'installation de l'environnement de développement, \cite{labrecque,flair_pros_cons}
    \item Apporte de la cohérence au niveau des technologies utilisées, au sein de l'équipe, \cite{labrecque, data-flair_use_cases}
    \item Rend le debugging dû aux environnements de développement plus facile, \cite{labrecque,koukia}
    \item Facilite la configuration, car elle est en gande partie déjà réalisée, \cite{data-flair_pros_cons}
    \item Compatible avec tous les OS.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Gestion de la BD potentiellement plus compliquée,
    \item \Gls{docker} peut avoir des problèmes de performances, \cite{labrecque}
    \item Nécessite Docker et les connaissances qui vont avec. \cite{labrecque}
\end{itemize}
%]%\blindtext\blindtext
%\end{multicols}
% TODO reciter besoins et dire solution qui se rapproche le plus

%\begin{multicols}{2}[
Passons maintenant au passage de l'environnement Laravel en machine Docker.
Pour ceci, nous allons énumérer les avantages et inconvénients d'installer nativement cet environnement.
Avantages:
\begin{itemize}
    \item (Meilleur performance),
    \item Gestion totale de l'environnement.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Peut générer des conflits si plusieurs versions sont présentes,
    \item Impossibilité d'avoir plusieurs versions différentes installées,
    \item L'installation demande du temps,
    \item Configuration à faire à la main,
    \item Fort risque d'erreur lors de la configuration,
    \item Installation différente pour chaque \Gls{os}.
\end{itemize}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir l'environnement Laravel en machine Docker.
Avantages:
\begin{itemize}
    \item Accélère l'installation de l'environnement de développement, \cite{labrecque}
    \item Apporte de la cohérence au niveau des technologies utilisées, au sein de l'équipe, \cite{labrecque, data-flair_use_cases}
    \item Rend le debugging dû aux environnements de développement plus facile, \cite{labrecque,koukia}
    \item Facilite la configuration, car elle est en gande partie déjà réalisée, \cite{data-flair_pros_cons}
    \item Compatible avec tous les OS,
    \item Existance d'un outil donné par Laravel et conçu pour être utiliser avec \Gls{docker}, il s'agit de \href{https://laravel.com/docs/9.x/sail}{Sail},
    \item Permet d'avoir plusieurs versions installées.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item \Gls{docker} peut avoir des problèmes de performances, \cite{labrecque}
    \item Nécessite Docker et les connaissances qui vont avec. \cite{labrecque}
\end{itemize}
%]%\blindtext\blindtext
%\end{multicols}
% TODO reciter besoins et dire solution qui se rapproche le plus

%https://laravel.com/docs/9.x/sail
%https://laravel.com/docs/9.x/homestead

%\begin{multicols}{2}[
Finalement, parlons du passage de l'environnement Vue.js en machine Docker.
Pour ceci, nous allons énumérer les avantages et inconvénients d'installer nativement cet environnement.
Avantages:
\begin{itemize}
    \item (Meilleur performance),
    \item Node.js possède un bon gestionnaire de version,
    \item Compatible avec tous les OS,
    \item Gestion totale de l'environnement.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Configuration à faire à la main,
\end{itemize}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir l'environnement Laravel en machine Docker.
Avantages:
\begin{itemize}
    \item Rapide à installer,
    \item Configuration en gande partie déjà réalisée,
    \item Compatible avec tous les OS.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Nécessite Docker et les connaissances qui vont avec,
    \item Peut-être compliqué à mettre en place.
\end{itemize}
%]%\blindtext\blindtext
%\end{multicols}
% TODO reciter besoins et dire solution qui se rapproche le plus

Suite à cette analyse des outils, la solution la plus adaptée semble être de mettre en place l'environement de développment suivant:

\begin{table}[h]
    \begin{center}
        \caption{Environement de développment choisi \label{env_dev}}
        \begin{tabular}{c|l|r}
            Outil             & Technologie utilisée  \\ \hline
            SGBD - MySQL      & Docker                \\
            Frontend - Vue.js & Installation native   \\
            Backend - Laravel & Laravel Sail (Docker) \\
        \end{tabular}
    \end{center}
\end{table}


Finalement cela correspond à la figure numéro %TODO \href{}{}.

% prod
\clearpage
\subsection{Infrastructures de production}

\subsubsection{Présentation des infrastructures de production \Gls{devops} possibles}
L'infrastructure de production que vous pouvez voir dans la figure ci-dessous et celle qui était utilisée lorsque j'ai reprise le projet.
En résumé, tous les outils ont été installés nativement sur la machine de développement sans virtualisation.
\figi{infrastructure_prod_actuelle.xml}{16cm}{Infrastructure de production actuelle}
%\fig{infrastructure_prod_actuelle.xml}{Infrastructure de production actuelle}

Cette figure-ci, montre la première amélioration possible, c'est à dire, de passer le SGBD en container docker.
\figi{infrastructure_prod_db_docker.xml}{16cm}{Infrastructure de production avec une db en docker}
%\fig{infrastructure_prod_db_docker.xml}{Infrastructure de production avec une db en docker}

Cette figure-ci, montre la secondes amélioration possible (mais aussi la première), c'est à dire, de passer l'application web réalisée avec le framework Laravel en container docker.
\figi{infrastructure_prod_db_laravel_docker.xml}{16cm}{Infrastructure de production avec une db et laravel en docker}
%\fig{infrastructure_prod_db_laravel_docker.xml}{Infrastructure de production avec une db et laravel en docker}

\subsubsection{Comparaison des infrastructures de production \Gls{devops} possibles}
Les différentes infrastructures possibles désormais présentées, il est nécessaire de les comparer en listant les pour et les contres de chaque changement en prenant comme référentielle l'infrastructure actuelle.
Les deux améliorations (combinées ou non) proposées sont les suivantes:
\begin{itemize}
    \item Passage du SGBD en machine Docker,
    \item Passage du projet Laravel (et toutes ces technologies) en machine Docker.
\end{itemize}

%\begin{multicols}{2}
%[

Nous recommençons également par réfléchir sur le passage du SGBD en machine Docker.
Pour ceci, nous allons énumérer les avantages et inconvénients d'installer le SGBD nativement.
Certains peuvent être les mêmes qu'énumérer dans la partie "Infrastructure de développement". %\href TODO
Avantages:
\begin{itemize}
    \item Gestion de la BD plus facile car le SGB est installé nativement,
    \item Sauvegarde aisément réalisable,
    \item Mise en place d'un service de façon trivialle,
    \item Le SGBD peut-être déjà installé et peut être utilisée directement,
    \item Ne nécessite pas Docker.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Demande du temps pour l'installation,
    \item Configuration à réaliser à la main,
    \item Fort risque d'erreur lors de la configuration,
    \item Installation différente pour chaque OS.
\end{itemize}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir le SGBD en machine Docker.
Avantages:
\begin{itemize}
    \item Accélère l'installation de l'environnement de production,
    \item Facilite la mise à jour de l'environnement de production si l'environnement de développement intègre un containeur docker pour le SGBD,
    \item Configuration en gande partie déjà réalisée,
    \item Compatible avec tous les OS.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Gestion de la BD potentiellement plus compliquée,
    \item Sauvegarde de la BD potentiellement plus compliquée,
    \item Mise en place d'un service non trivial,
    \item \Gls{docker} peut avoir des problèmes de performances, \cite{labrecque}
    \item Nécessite Docker et les connaissances qui vont avec. \cite{labrecque}
\end{itemize}
%]%\blindtext\blindtext
%\end{multicols}
% TODO reciter besoins et dire solution qui se rapproche le plus

%\begin{multicols}{2}[
Passons maintenant au passage de l'environnement Laravel en machine Docker.
Pour ceci, nous allons énumérer les avantages et inconvénients d'installer nativement cet environnement.
Avantages:
\begin{itemize}
    \item (Meilleur performance),
    \item Gestion totale de l'environnement.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Mise à jour compliquée si un changement de version à lieu,
    \item L'installation demande du temps,
    \item Configuration à faire à la main,
    \item Fort risque d'erreur lors de la configuration,
    \item Installation différente pour chaque \Gls{os}.
\end{itemize}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir l'environnement Laravel en machine Docker.
Avantages:
\begin{itemize}
    \item Mise à jour du programme facilitée, dans tous les cas,
    \item Accélère l'installation de l'environnement de production,
    \item Configuration en gande partie déjà réalisée,
    \item Offre une possibilité d'extensibilité horizontale,
    \item Compatible avec tous les OS.
\end{itemize}

Inconvénients:
\begin{itemize}
    \item Peut laisser des failles de sécurité, suivant l'environnement mis en place,
    \item \Gls{docker} peut avoir des problèmes de performances, \cite{labrecque}
    \item Nécessite Docker et les connaissances qui vont avec. \cite{labrecque}
\end{itemize}
%]%\blindtext\blindtext
%\end{multicols}

% TODO reciter besoins et dire solution qui se rapproche le plus

% TODO pour le déploiment, regarder pourquoi certains sont parti de docker


Suite à cette analyse des outils, la solution la plus adaptée semble être de mettre en place l'environement de développment suivant:

\begin{table}[h]
    \begin{center}
        \caption{Environement de développment choisi \label{env_prod}}
        \begin{tabular}{c|l|r}
            Outil             & Technologie utilisée \\ \hline
            SGBD - MySQL      & Docker               \\
            Backend - Laravel & Docker               \\
        \end{tabular}
    \end{center}
\end{table}

\subsubsection{Analyse de risques}
% comment protéger une infra en prod
% contacter des profs de sécu
% lister ce qu'on va mettre en place
% on est resté en surface, il faudrait investir des experts pour évaluer. (audit par exemple)
% sécurité pas prise en compte dans le projet car pas dans objectif, pas le luxe de rechercher car trop de temps, à mentionner dans le rapport.

L'analyse de risques de l'infrastructure de production est point très important lorsque que l'on publie un logiciel. Cette dernière peut être très complexe et nécessite énormément de connaissance.
Une analyse de risque complète demande une quantité conséquent de travail. L'intervention d'expert dans le domaine, via par exemple, des audits serait une solution pour réaliser cette partie du projet
L'analyse de risques ne pourra donc pas être réaliser lors de ce projet, pour toutes les raisons énumérées plus haut, mais aussi car ce n'est pas le but principal de ce dernier.
J'ai donc décider d'appliquer tout ce que je connaissais et faire le meilleur travail possible sans aller en profondeur dans le sujet.

% devops
%https://blog.logrocket.com/how-to-create-a-ci-cd-for-a-laravel-application-using-github-actions/

\clearpage
\subsection{Pipeline DevOps}
\subsubsection{Introduction aux \Gls{devops}}
%https://www.youtube.com/watch?v=scEDHsr3APg
%https://www.padok.fr/blog/devops-tout-savoir
%https://azure.microsoft.com/en-us/overview/what-is-devops/#devops-overview
%https://www.ibm.com/cloud/learn/devops-a-complete-guide
Pour commencer, c'est quoi les DevOps?
Les DevOps c'est un ensemble de processus qui permettent de gérer et faciliter le développement et le déploiement continu de l'application. Cela permet de garantir une meilleur qualité du code et de simplifier l'intégration de ce dernier. C'est-à-dire, si un collaborateur souhaite ajouter sa partie du code au projet, il doit d'abord passer par un système automatisé de contrôle et d'intégration de son code avant de pouvoir l'ajouter. Cette partie est appelée \Gls{ci}.
Les DevOps intègre également tout ce qui est déployement continu et livraison continue (\Gls{cd}).
En pratique, ils intègrent également d'autre aspect, comme la maintenance de l'infrastructure de production et développement, la sécurité des processus et beaucoup d'autres concepts.
Au final c'est un cycle de vie visant à faciliter le développement d'applications en équipe.
Ci-dessous, on peut observer un exemple de lifecycle fourni par IBM:
\begin{figure}
    %\href{https://www.docker.com/wp-content/uploads/2021/11/container-what-is-container.png}
    %{\includegraphics[width=\textwidth]{picture}}
    \caption{IBM lifecycle DevOps}
\end{figure}


Aucun Devops ou pipeline n'avait été réalisé lors du précédent projet.
Nous avons donc que des propositions, sans solution existante (ce qui était le cas pour d'autres choix).
Avant de présenter chacun des pipeline DevOps proposé, il est nécessaire d'expliquer pourquoi chacun de ces derniers passent par Github, et plus précisément, les Github Actions.

\subsubsection{Pourquoi Github?}
Tout d'abord, il faut comprendre qu'il existe d'autres outil de "gestion" de \Gls{devops}, appelé aussi services de \Gls{ci} / \Gls{devops}, en voici une liste non exhaustive:
\begin{itemize}
    \item Jenkins, %https://www.jenkins.io/
    \item TeamCity, %https://www.jetbrains.com/teamcity/
    \item CircleCI, %https://www.guru99.com/top-20-continuous-integration-tools.html
    \item Travis-CI, %https://www.travis-ci.com/
    \item GitLab, %https://about.gitlab.com/
    \item Bamboo, %https://www.atlassian.com/software/bamboo
    \item GoCD, %https://www.gocd.org/
    \item Azure DevOps. %https://azure.microsoft.com/fr-fr/services/devops/
\end{itemize}

Tous ces outils, mise à part GitLab, doivent être installé en plus et configurer pour le projet.
Comme il s'agit d'un projet assez restreint et n'impliquant que peu de personnes, nous cherchons à rester dans une solution simple et donc "all in one".
Nous n'allons donc pas plonger dans les détails de chaque technologie citée plus haut.
Parmi les solutions "all in one", c'est-à-dire qui propose des services de \Gls{ci} / \Gls{devops} et permette le versioning de code, il reste uniquement GitLab et Github comme choix.
Ne souhaitant pas réaliser une profonde analyse sur ces 2 solutions, car les 2 étant souvent considérées comme équivalentes ou interchangeable, ma connaissance de la solution Github est un argument suffisant, selon moi, pour faire pencher la balance en sa faveur.
% Tous les outils CI / CD
%https://katalon.com/resources-center/blog/ci-cd-tools#
%https://www.lambdatest.com/blog/31-best-ci-cd-tools/
%https://www.guru99.com/top-20-continuous-integration-tools.html
%https://stackshare.io/stackups/github-actions-vs-gitlab-ci#pros

\subsubsection{Présentation des pipeline \Gls{devops} possibles}
Ce premier pipeline possible possède uniquement un intérêt si l'infrastructure de production tourne à l'aide de conteneurs Docker. En effet, le but est de construire l' /les image(s) Docker contenant tout ce qui est nécessaire (configurations, programmes, etc.) au niveau de la machine de développement, puis d'envoyer cette / ces dernière(s) sur un repository d'image, en l'occurence, Dockerhub. Puis de récupérer cette / ces images sur la machine de production et les lancer simplement.
\figi{devops_dockerhub.xml}{16cm}{DevOps via dockerhub}
%\fig{devops_dockerhub.xml}{DevOps via dockerhub}

Ce second pipeline, passerait par une plateforme appelée Heroku. Heroku permet de déployer son application sur l'un de leur serveur, puis le redéployer sur une machine de production finale.
Cette approche est très intéressante car l'étape intermédiaire permet de tester l'application sur une autre machine que celle de développement et ceci avant de livrer en production.
\figi{devops_heroku.xml}{16cm}{DevOps via heroku}
%\fig{devops_heroku.xml}{DevOps via heroku}
%https://devcenter.heroku.com/articles/getting-started-with-laravel

Finalement, le pipeline passant uniquement par Github, est la solution la plus simpliste en terme du nombre de technologies utilisées. Cette dernière repose sur le fait de simplement pousser le code sur Github et de le mettre à jour sur la machine de production via un script qui récupère les données sur le Github.
\figi{devops_github.xml}{16cm}{DevOps via github}
%\fig{devops_github.xml}{DevOps via github}

\subsubsection{Comparaison des pipeline \Gls{devops} possibles}
Nous allons définir pour chacun des pipeline, les avantages et inconvénients de ces derniers.
% pipeline docker
Commençons par le pipeline Docker:
\begin{itemize}
    \item x
\end{itemize}

Inconvénients:
\begin{itemize}
    \item x
\end{itemize}

Continuons avec le pipeline Heroku:
\begin{itemize}
    \item x
\end{itemize}

Inconvénients:
\begin{itemize}
    \item x
\end{itemize}

Finissons avec le pipeline Github:
\begin{itemize}
    \item x
\end{itemize}

Inconvénients:
\begin{itemize}
    \item x
\end{itemize}

% TODO reciter besoins et dire solution qui se rapproche le plus

\clearpage
\subsection{\Gls{sgbd}}
% postgre vs mysql
%https://www.geeksforgeeks.org/difference-between-mysql-and-postgresql/
%https://www.simplilearn.com/tutorials/sql-tutorial/postgresql-vs-mysql
%https://www.ibm.com/cloud/blog/postgresql-vs-mysql-whats-the-difference
%https://stackshare.io/stackups/mysql-vs-postgresql

% upgrade to laravel 9
%https://laravel.com/docs/9.x/upgrade
%https://github.com/laravel/vonage-notification-channel/blob/3.x/UPGRADE.md

\chapter{Conception et Réalisation de la base de données}
%todo à rendre aussi pour le premier rendu
%todo MLD
%todo model de l'ORM

\chapter{Conception et Réalisation du Backend / de l'API}
%todo à rendre aussi pour le premier rendu
%todo architecture de code
\subsection{Architectures de code}
\figi{architecture_code_spring.xml}{16cm}{Architecture de code du framework Spring "classique"}
%\fig{architecture_code_spring.xml}{Architecture de code du framework Spring "classique"}

\figi{architecture_code_laravel.xml}{16cm}{Architecture de code du framework Laravel "classique"}
%\fig{architecture_code_laravel.xml}{Architecture de code du framework Laravel "classique"}

\figi{architecture_code_laravel_proposee.xml}{16cm}{Architecture de code Laravel proposée}
%\fig{architecture_code_laravel_proposee.xml}{Architecture de code Laravel proposée}
%\fig{architecture_code_laravel_proposee.svg}{Architecture de code Laravel proposée}
%\figi{architecture_code_laravel_proposee}{10cm}{Architecture}
%\fig{architecture_code_laravel_proposee}{Architecture de code Laravel proposée}

% ensuite décrire ce qu'on a mis en place et indiquer s'il y a des failles

% surtout indiquer tout ce qu'on a fait et tout ce que j'ai pas fait
% et pourquoi je l'ai pas fait, pas compris qqch ou pas eu le temps, pas la priorité, pas de sources suffisantes

%dans le texte (Labrecque, 2018)
%\cite{labrecque}

%suivantes:
%(Labrecque, 2018; x, yyyy;)
%pour reformuler

%Labrecque M. (2018). Pros and cons of Docker. in \textit{Docker, planet drupal}. consulté à %l'adresse: https://affinitybridge.com/blog/pros-and-cons-docker (consulté le 31.03.2022)

\chapter{Intégration continu (\Gls{ci})}

%php unit

\chapter{Déploiement continu (\Gls{cd})}

\chapter{Reprise du projet}

\section{Récupération du physique du projet}

\section{Erreurs restantes}

\section{Améliorations possibles}

%%if
\chapter{Bibliographie}
\section{Citations et bibliographie}
%Citer vos sources est essentiel. Avec \texttt{biblatex} vous pouvez facilement citer des articles, des livres ou des sites internet. Toutes les citations dans le texte seront automatiquement regroupées en fin de document dans la section \guillemotleft Bibliographie\guillemotright. Par exemple, citons un article d'Einstein \cite{einstein} ou le livre de Dirac \cite{dirac}.

Parfois il peut être utile d'utiliser un gestionnaire de bibliographie. La communauté académique recommande l'outil \href{https://www.zotero.org/}{Zotero} qui permet de gérer une bibliothèque numérique d'ouvrages et de références numériques. Il permet également de générer une bibliographie compatible avec \LaTeX.


\mintinline{latex}{\SI{42.12}{\kilo\gram\metre\per\square\second}}\par
%%fi

\chapter{Conclusion}

%%if
Bien que non nécessaire dans un rapport de Bachelor, la discussion finale d'un projet résume les résultats obtenus et dresse une conclusion objective du projet. Un manager de société est souvent amené à lire de nombreux rapport, il ne s'intéresse généralement qu'à l'introduction au contexte de l'étude et à sa conclusion.

Il est de coutume de signer la conclusion...
%%fi

\vfil
\hspace{8cm}\makeatletter\@author\makeatother\par
\hspace{8cm}\begin{minipage}{5cm}
    %%if
    % Place pour signature numérique
    \printsignature
    %%fi
\end{minipage}
\clearpage

\appendix
\appendixpage
\addappheadtotoc

%%if
\chapter{Première annexe}

Les annexes n'ont pas un contenu \underline{normatif} mais \underline{descriptif}. Tout contenu annexé ne doit pas être nécessaire à la bonne compréhension du travail.

Les annexes contiennent généralement :

\begin{itemize}
    \item les dessins mécaniques (mises en plan);
    \item les schémas électriques détaillés;
    \item des photographies du projet;
    \item des scripts et des extraits de code source;
    \item des documents techniques \pex \emph{datasheet};
    \item des développements mathématiques.
\end{itemize}
\section{Sous section}
\lipsum[1]
%%fi

\let\cleardoublepage\clearpage
\backmatter

\label{glossaire}
\printnoidxglossary
\printbibliography
\label{index}
\printindex

%%if
\clearpage
\Large\textbf{Colophon :}\par\normalsize
\thispagestyle{empty}
La qualité de cet ouvrage repose que le moteur \LaTeX. La mise en page et le format sont inspirés d'ouvrages scientifiques tels que le modèle de thèse de l'EPFL et celui des publications O'Reilly.

Les diagrammes et les illustrations sont édités depuis l'outil en ligne draw.io. Certaines illustrations ont été reprises dans Adobe Illustrator. Les représentations 3D sont exportées de SolidWorks et certains graphiques sont générés à la volée depuis un code source Python.

L'auteur fictive de ce document \emph{Maria Bernasconi} est un nom emprunté, par amusement, aux spécimens publiés par Postfinance.

Ce document a été compilé avec XeLaTeX.

La famille de police de caractères utilisée est \emph{Computed Modern} créée par Donald Knuth avec son logiciel METAFONT.
\vfil
Le Colophon est le dernier élément d'un document qui contient des notes de l'auteur concernant la mise en page et l'édition du document : il est parfaitement optionnel.
%%fi

\end{document}
