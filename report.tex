\documentclass[
    iai, % Saisir le nom de l'institut rattaché
    il, % Saisir le nom de l'orientation
    %confidential, % Décommentez si le travail est confidentiel
]{heig-tb}

\usepackage[nooldvoltagedirection,european,americaninductors]{circuitikz}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{pdfpages}
\usepackage{lscape}

\signature{signature_alec_berney.svg}

\makenomenclature
\makenoidxglossaries
\makeindex

\addbibresource{bibliography.bib}

\input{nomenclature}
\input{acronyms}
\input{glossary}
\input{meta}

\surroundwithmdframed{minted}

%% Début du document
\begin{document}
\selectlanguage{french}
\maketitle
\frontmatter
\clearemptydoublepage

%% Requis par les dispositions générales des travaux de Bachelor
\preamble
\authentification

%% Résumé / Version abbrégée
\begin{abstract}
    \input{abstract}
\end{abstract}

%% Sommaire et tables
\clearemptydoublepage
{
    \tableofcontents
    \let\cleardoublepage\clearpage
    \listoffigures
    \let\cleardoublepage\clearpage
    \listoftables
    \let\cleardoublepage\clearpage
    \listoflistings
}

\printnomenclature
\clearemptydoublepage
\pagenumbering{arabic}

%% Contenu
\mainmatter

\chapter{Introduction}
L'introduction est une section requise dans un rapport technique. Introduisez votre travail, l'idée de départ et les objectifs attendus. Un lecteur qui découvrirait votre projet au travers de cette introduction devrait ainsi être capable d'en comprendre le cadre, l'idée générale et les aboutissants du projet.

\section{Contexte}
Le \Gls{fablab} est un laboratoire permettant de réaliser des travaux sur des machines de ce dernier. Actuellement, pour réaliser un travail sur une machine, il est nécessaire de réaliser une demande par email à l'un des techniciens ayant le droit d'usiner sur la machine souhaitée. Une fois la demande reçue, le technicien usine dès qu'il le peut et doit recontacter le mandataire pour lui donner son travail fini. Durant toute cette période, aucun retour n'a été donné au mandataire. En cas de problème avec un travail, le technicien doit également recontacter le client.\newline
Certains défauts majeurs peuvent être identifier avec la procédure actuelle, les voici :
\begin{itemize}
    \item Il n'y a aucun suivi des travaux pour le mandataire, \cite{lieberherr}
    \item Les échanges liés aux travaux peuvent être réalisé via plusieurs canaux (email, \Gls{teams}, vocal, etc.), \cite{lieberherr}
    \item Risque de désorganisation, \cite{lieberherr}
    \item Manque de clarté quant à la procédure, \cite{lieberherr}
    \item Aucun historique des travaux réalisé,
    \item Gestion problèmes survenus lors du travail compliqué.
\end{itemize}
Une première partie du projet a déjà été réalisée lors du travail de Bachelor de monsieur Tristan Lieberherr. De ce fait aucun cahier des charges n'était défini à l'origine, car il était d'abord nécessaire d'effectuer une analyse du projet afin de définir les points d'améliorations qu'allaient contenir le cahier des charges.

\section{But du travail de Bachelor}
Le but, plus global, de ce travail de Bachelor, est de fournir une application web au fablab afin de faciliter la gestion et le suivi des demandes de travaux pour leur laboratoire.

Le but au niveau technique est de fournir une application déployée en production.\newline
Il est également important de significativement améliorer le travail déjà existant en ajoutant certaines fonctionnalités et améliorant la qualité du code.\newline
Cette application devra reposer sur une base de données bien conçues et ayant déjà prévu certains améliorations possibles. Elle devra également posséder un backend propre permettant de reprendre et l'améliorer sans devoir tout repenser.\newline
La qualité de l'environnement de travail et de production ne seront pas à négliger et devront être facilement repris en main par la futur équipe s'occupant du projet.

\section{État de la situation}
Cette section permet de définir ce qui a déjà été réalisé et de l'analyser.\newline
Pour commencer, il faut savoir que le travail fourni est déjà fonctionnel et fait l'objet d'une documentation suffisante pour le reprendre en main.\newline
Le choix des technologies déjà utilisées sera abordé plus tard dans le document.

\subsection{Analyse du système existant}
Dans cette partie, nous allons énumérer tous les aspects de l'ancien travail fourni. Nous n'allons pas toucher le détail, car le but est de faire ressortir seulement les points essentiels.

\subsubsection{Environement de développement}
Pour commencer, parlons de l'environnement de travail. Il faut savoir que le projet a été transmi avec 2 dépôts \Gls{github} au nom de l'ancien Bachelier et le rapport de l'ancien travail de Bachelor.

Maintenant, voici les points qui ressortent de l'analyse concernant l'environnement de travail:
\begin{itemize}
    \item 2 dépôts (repository) \Gls{github} à son nom sont fournis,
    \item Les 2 dépôts ne contiennent que très peu d'information concernant le projet,
    \item Le projet tourne sur d'anciennes technologies améliorées depuis,
    \item Le projet n'est pas si aisé à reprendre en moins suite au manque d'informations concernant les technologies,
    \item L'environnement de développement est difficilement transmissible à une tierce personne, il est compliqué de vite intégrer l'équipe de développement,
    \item Aucun outil de collaboration n'est fourni, nous parlons ici de \Gls{devops} (\Gls{ci} et \Gls{cd}).
\end{itemize}

\subsubsection{Base de données}
Cette partie défini tout ce qui touche à la base de données et influence également le \Gls{backend}.\newline
Les points ressortant de l'analyse de la base données sont les suivants:
\begin{itemize}
    \item La base de données contient les ressources principales (utilisateurs, travaux, messages, fichiers),
    \item La base de données possèdent de la redondance paraîssant inutiles,
    \item La base de données ne peut pas intégrer la gestion de plusieurs rôles,
    \item La base de données n'intégrent pas la notion de machines et de catégories de travaux,
    \item La gestion des types de fichiers acceptés pour les travaux n'est pas présente.
\end{itemize}

\subsubsection{Backend / API}
Passons maintenant au Backend qui est la plus grosse partie du travail.\newline
Il faut savoir que toute l'analyse de la base de donnée s'applique également pour une bonne partie du Backend et ne sera pas répétée.\newline
Les points ressortant de l'analyse de ce dernier sont les suivants:
\begin{itemize}
    \item Le principe \Gls{rest} n'est pas respecté en ce qui concerne l'\Gls{api},
    \item Les entrées utilisateurs ne font l'objet d'aucune vérification syntaxique et sémantique,
    \item L'architecture de code ne respecte pas totalement celle mise à disposition par \Gls{laravel},
    \item Le code n'utilise pas toutes les possibilités utiles fournies par le \Gls{framework},
    \item Le contrôle de l'accès aux ressources via des rôles n'est pas mis en place,
    \item Le système de stockage de fichier et fonctionnel,
    \item Le système de notification via est fonctionnel, mais malheureusement non sécurisé,
    \item Les travaux d'arrière plan envoyant des emails est fonctionnel,
    \item Le Backend utilise une version antérieur du framework,
    \item Le Backend est actuellement entièrement fonctionnel.
\end{itemize}

\subsubsection{Frontend}
Finalement, passons au frontend, ce dernier a été réalisé à l'aide d'un \Gls{template}. Il a été adapté aux besoins de l'application. Le but du projet n'étant pas concentrer sur le frontend, seul une analyse de surface a été réalisée.\newline
Les points ressortant de l'analyse de ce dernier sont les suivants:
\begin{itemize}
    \item Le frontend est totalement fonctionnel,
    \item Les entrées utilisateurs ne font l'objet d'aucune vérification syntaxique et sémantique,
    \item Le projet possède des dépendances obsolètes et non mise à jour,
    \item Les valeurs textuelles sont toutes insérées directement dans le code et n'offre pas la possibilité de traduire facilement le site,
    \item Les valeurs concernant les machines et les catégories de travaux sont "hardcodées" dans le frontend.
\end{itemize}

\subsection{Propositions d'améliorations}

\subsubsection{Environement de développement}
Concernant l'environnement de travail, il est important d'améliorer significativement la façon dont une personne s'intégrer au travail, à l'équipe de développement.\newline
Pour commencer, il est nécessaire de créer une orgranisation github acceuillant les 2 dépôts Github. Chaque dépôt devra lister les technologies utilisées et indiquer comment les installer, ainsi que comment configurer facilement configurer son environnement de travail pour pariticiper au projet.\newline
Il sera également nécessaire de réaliser un suivi du travail grâce aux outils fourni par Github (issues, kanban, milestones, etc.).\newline
Fournir un environement aisément configurable pour tout un chacun est également un point essentiel.
Une CI devra impérativement être mise en place afin de faciliter le travail à plusieurs sur le projet. Il en va de même pour le CD, si l'on souhaite déployer aisément les différentes versions de l'application.

\subsubsection{Base de données}
La base de données fera l'objet d'une toute nouvelle conception pour améliorer tous les points énumérés précédement et intégrer les notions manquantes. Le Backend en sera fortement influencé.

\subsubsection{Backend}
Le Backend étant fortement influencé par la base de données, ce dernier se verra adminsitrer de gros changements.\newline
Les sujets sur lequel une amélioration devra être apportée sont les suivants:
\begin{itemize}
    \item Le principe REST devra être appliqué,
    \item Les entrées utilisateurs devront au moins faire l'objet d'une vérification syntaxique et peut-être sémantique,
    \item L'architecture de code se rapprochera le plus possible de ce qui est proposé par Laravel,
    \item Le code utilisera le plus possible les outils fournis par le framework,
    \item Le contrôle de l'accès aux ressources via des rôles sera mis en place,
    \item Le système de notification pourra être sécurisé et fera appel à l'API,
    \item Le Backend passera à la nouvelle version du framework.
\end{itemize}

Après avoir lister tous ces points, on se rend compte que le backend devra presque être réaliser de 0. Ce ne sera pas le cas, car l'ancien projet sera toujours présent comme référence en cas de questions.

\subsubsection{Frontend}
Les améliorations possibles concernant le frontend gravite essentiellement autour de la mise à jour des dépendances du projet et la façon dans les valeurs sont stockées.\newline
Un système de gestion des langues (ii8n) pourraient être envisagé, ainsi que vérifier les entrées utilisateurs.\newline
Le frontend sera surtout modifié pour être adapté aux changements du backend.

\section{Cahier des Charges}

\subsection{Prologue}

Le projet étant déjà existant, aucun cahier des charges n'était défini à l'origine. En effet, il était d'abord nécessaire de réaliser une analyse du projet afin de définir les points d'améliorations qu'allaient contenir le cahier des charges.

\subsection{Objectifs \label{objectifs}}

Les objectifs principaux du projet sont les suivants:
\begin{itemize}
    \item Mettre en place une infrastructure de développement professionnel,
    \item Mettre en place les DevOps pour le projet existant,
    \item Améliorer la conception de la base de données en ajoutant des données précieuses,
    \item Améliorer le backend du projet existant.
\end{itemize}

\newpage
Nous allons maintenant passer à la liste des tâches qui devront être effectuées durant le travail de Bachelor.

Pour les toutes les tâches qui seront listés plus bas, celles qui nécessitent une décomposition en plusieurs tâches voient le numéro de ses sous-tâches suivi d'une lettre. Les tâches possédant des sous-tâches des priorités différentes, n'auront aucune priorité globale.

Je m'engage à réaliser les tâches énumérées dans le tableau \ref{taches}.

\begin{table}[h]
    \begin{center}
        \caption{Liste des tâches / exigences à réaliser durant le projet \label{taches}}
        \begin{tabularx}{1.0\textwidth} {l|X|r}
            No. & Tâche / Exigence                                                                                                       & Priorité      \\ \hline
            1   & Créer une infrastructure de développement professionnel                                                                & Obligatoire   \\
            2   & Mettre en place un pipeline DevOps complet                                                                             & Obligatoire   \\
            2.a & Mettre en place la CI                                                                                                  & Obligatoire   \\
            2.b & Mettre en place la CD                                                                                                  & Obligatoire   \\
            2.c & Mettre en place une infrastructure de production accueillant le rendu du projet                                        & Obligatoire   \\
            3   & Mettre à jour le projet existant vers les nouvelles versions des technologies utilisées                                & Obligatoire   \\
            3.a & Mettre à jour le frontend                                                                                              & Obligatoire   \\
            3.b & Mettre à jour le backend                                                                                               & Obligatoire   \\
            4   & Reconcevoir la base de données                                                                                         & Obligatoire   \\
            4.a & La base de données doit prendre en compte les rôles des utilisateurs                                                   & Obligatoire   \\
            4.b & La base de données doit prendre en compte les ressources liées aux machines industrielles utilisées dans l'application & Obligatoire   \\
            5   & Améliorer le backend du projet                                                                                         &               \\
            5.a & Appliquer les standards de programmation web (REST)                                                                    & Obligatoire   \\
            5.b & Mettre en place une architecture de code cohérente                                                                     & Obligatoire   \\
            5.c & Mettre en place une vérification des entrées utilisateurs                                                              & Obligatoire   \\
            5.d & Mettre en place l'authentification de l'utilisateur                                                                    & Obligatoire   \\
            5.e & Ajouter la gestion des rôles des utilisateurs                                                                          & Obligatoire   \\
            5.f & Ajouter la gestion des ressources liées aux machines industrielles utilisées dans l'application                        & Intermédiaire \\
            5.g & Améliorer le système de notifications pour le rendre plus sécurisé                                                     & Basse         \\
            6   & Améliorer le frontend                                                                                                  &               \\
            6.a & Mettre à jour le frontend pour coller aux modifications des routes du backend / de l'api                               & Obligatoire   \\
            6.b & Ajouter la gestion des ressources liées aux machines industrielles utilisées dans l'application                        & Intermédiaire \\
            6.c & Améliorer le système de notifications pour le rendre plus sécurisé                                                     & Basse         \\
            7   & Tester l'application à l'aide de tests automatisés                                                                     & Obligatoire   \\
            7.a & Réaliser des tests unitaires automatisés                                                                               & Obligatoire   \\
            7.b & Réaliser des tests d'intégration automatisés                                                                           & Obligatoire   \\
        \end{tabularx}
    \end{center}
\end{table}

\newpage
\subsection{Déroulement global projet}

Le projet se réalise durant le semestre de printemps. Le semestre possède 14 semaines de travail de 1 jour et demi de travail si on exclut la semaine du CRUNCH et celle des vacances.\newline
Il y a ensuite 6 semaines à temps pleins pour finaliser le travail de Bachelor.

Une séance hebdomadaire est prévue avec le professeur responsable du travail, m. Chevallier.

Le projet est réparti en 3 principales phases, qui s'effectueront dans l'ordre suivant:
\begin{enumerate}
    \def\labelenumi{\arabic{enumi}.}
    \item L'analyse du projet:
          \begin{enumerate}
              \def\labelenumii{\alph{enumii}.}
              \item L'étude du projet et de ses technologies,
              \item Les choix technologiques et conceptuels.
          \end{enumerate}
    \item La conception et réalisation du projet, contenant principalement:
          \begin{enumerate}
              \def\labelenumii{\alph{enumii}.}
              \item La mise en place des environnements de développement et de production,
              \item La réalisation des DevOps,
              \item L'amélioration du Backend et de la base de données,
              \item La modification du Frontend.
          \end{enumerate}
    \item La préparation des livrables.
\end{enumerate}

La première phase d'analyse a pour objectif de définir tout le cadre théorique du projet et les divers choix à réaliser tout au long de ce dernier.\newline
Cette phase devrait se terminer à la fin de la semaine numéro 7 ou 8.\newline
Tout en sachant que cette phase contient l'écriture du cahier des charges et que ce dernier doit être rendu au plus tard 6 semaines après le début du travail de bachelor, c'est-à-dire, le 10.04.2022.

La seconde phase, concernant la conception et la réalisation du projet est la plus conséquente.
Cette dernière suivra la première et devrait se terminer lors de la 20ème semaine si tout se déroule comme prévu.

La dernière phase, concernant la préparation des livrables, est une phase importante qui se réalisera tout au long du projet et se terminera la dernière semaine du travail de bachelor.

Un rendu intermédiaire est également prévu après 150 heures de travail et possède comme date le 11.05.2022.

\subsection{Résultats attendus}

Les résultats attendus pour ce projet dépendent énormément des tâches établies définies dans la partie \ref{objectifs} du cahier des charges.\newline
En effet, chaque tâche définie est vérifiable et sera donc utilisée pour évaluer le résultat du projet.
\newpage

\chapter{Analyse}

\section{Planning}
Cette section a pour but d'apporter une discussion sur le planning et son évolution.
Le planning est disponible en annexe.

\subsection{Description générale du planning}

Dans le document, certaines couleurs apparaîssent, en voici les significations:
\begin{itemize}
    \item La colonne en gris indique une semaine sans travail,
    \item Le bleu indiquant quand les tâches seront réalisées,
    \item En orange clair, les tâches réalisées tout au long du projet,
    \item En rouge, les rendus / jalons importants du projet.
\end{itemize}

La semaine sans travail est un choix personnel, cette semaine là, nous avons une semaine spéciale à l'HEIG, le Crunch. C'est une semaine interdisciplinaire obligatoire.

Il faut savoir qu'il y aura sûrement une grande différence entre la réalisation des tâches indiquées et la réalité. En effet, dans les projets comme celui-ci, il est souvent nécessaire de jongler entre les différentes tâches et il est donc compliqué de suivre un planning en cascade comme celui-ci.

Le planning est séparé en trois grandes parties:
\begin{itemize}
    \item L'analyse,
    \item La conception et la réalisation,
    \item La préparation des livrables.
\end{itemize}

La conception et réalisation ne sont pas séparées car je vais devoir altérner entre les deux, c'est-à-dire que je vais souvent concevoir quelque chose, le réaliser, me rendre compte que ce n'est pas optimal et répéter le processus. C'est pour cela que ces deux parties sont liés et non séparées, afin de travailler itérativement, comme cela se fait beaucoup en développement.

\subsection{Analyse}
L'analyse contient principalement de l'étude et des choix technologiques. Certains prototypes peuvent être réalisé pour consolider les choix effectués. Tous les choix technologiques et conceptuels sont cruciaux pour la suite du projet.\newline
La justification des choix à l'aide d'articles scientifiques sera également un point à ne pas négliger au niveau du temps consacré.

\subsection{Conception et réalisation}
La partie conception et réalisation est séparée en plusieurs sections:
\begin{itemize}
    \item Mise en place de l'environnement de développement et de production,
    \item DevOps,
    \item Backend et base de données,
    \item Frontend.
\end{itemize}

Les points à ne pas sous-estimer dans ces parties sont la mise en place d'un bon environnement de travail / de développement et la CI pour la première partie du projet. Ces deux points sont essentiels pour pouvoir développer l'application sans problème.\newline
Deux sujets sur la conception peuvent prendre du temps et sont très important, il s'agit de la conception de la base de données, car celle-ci découle sur toute la réalisation du backend et la conception de l'architecture de code, car si elle est significativement changée au milieu du projet, peut faire perdre énorméement de temps.\newline
Un point qui a été mal identifié de ma part lorsque j'ai réalisé ce planning, c'est le fait que de concevoir toute une nouvelle base de données allaient presque obliger à développer le backend quasiment de zéro sans pouvoir utiliser significativement le travail déjà présent.\newline
Cette partie était presque prévue sous le point "Séparation et refactor du code déjà écrit" mais elle prendra beaucoup plus de temps que prévu. Elle va s'en doute s'étendre à plus de 80 heures de travail.\newline
En plus, cette partie est cruciale pour le projet car elle correspond à la base de l'API et doit être solide pour pouvoir itérer dessus.

\subsection{Livrables}
En ce qui concerne la préparation des livrables, il est clair que le rapport est l'un des points demandant le plus de temps du travail et est crucial pour la réussite du projet. Ce dernier se réalisant tout au long du projet, il n'a pas de date précise où il va être réaliser. On peut cependant prévoir plus d'effort avant le rendu intermédiaire et le rendu final.\newline
En ce qui concerne la présentation de la défense est indiquée mais sera uniquement réalisée pendant le mois d'août.\newline
La partie gestion de projet est également et logiquement réalisée tout au long du projet.

%TODO: Demander si je dois rechanger à cause de tout refaire le backend?


\section{Choix technologiques}

Dans cette section, je vais énumérer tous les choix technologiques ou conceptuels liés au projet.
Mais avant cela, il est nécessaire de définir précisément les besoins pour le projet afin de réaliser des choix cohérents en fonction de ces derniers.\newline
Pour chaque choix, technologiques ou conceptuels, une liste des possibilités réalisables sera énumérée et si possible représentée visuellement.\newline
Cette liste de possibilités sera accompagnées des avantages et inconvénients de chaque solution en s'inspirant des besoins du projet.

\subsection{Rappel des choix technologiques déjà effectués}
Dans cette section, je vais énumérer les choix technologiques déjà effectués par le premier étudiant ayant travaillé sur le projet.\newline
Considérant les choix de l'étudiant comme bon et bien argumenté, je ne vois aucune raison de les remettre en question, surtout qu'un travail conséquent a déjà été réalisé avec les technologies choisies. Pour plus de précisions sur ces choix technologiques, je vous invite à consulter son %\href{TODO}{rapport}. //voir avec prof %mettre url tb.heig-vd.ch sur rapport dans biblio
Voici un résumé des décisions prises lors de la première phase du projet:
\begin{itemize}
    \item Backend: PHP avec le framework \href{https://laravel.com/}{Laravel},
    \item Frontend: \Gls{javascript} avec \href{https://vuejs.org/}{Vue.js},
    \item SGBD: \href{https://www.mysql.com/}{MySQL},
    \item Outil SSO: Shibboleth. %https://blog.miniorange.com/what-is-shibboleth/
\end{itemize}

Au final, la "stack" de technologies utilisées ressemble à celle de la figure \ref{stack-old-tb}

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/stack-old-tb.png}
        \caption[Stack de technologies]{Stack de technologies utilisées via
            \href{https://stackshare.io/alecberney/bachelors-thesis}{stackshare} \label{stack-old-tb}}
    \end{figure}
\end{center}

\subsection{Besoins pour le projet}
Je vais ici définir les besoins du projet et ceci en les séparant par parties distinctes.

\subsubsection{Besoins pour l'infrastructure de développement}
Pour commencer, définissons l'infrastructure de développement.\newline
L'infrastructure de développement englobe tous les outils à installer et toutes les configurations à réaliser sur un pc vierge afin que le développeur puisse commencer à développer l'application.
En général, ce qui est recherché, c'est la simplicité et la rapidité de configuration de cet environnement.\newline
Dans notre cas, pour que le développeur puisse commencer à développer, il doit principalement mettre en place les outils suivants:
\begin{itemize}
    \item un IDE (Integrated Development Environment), de préférence Visual Studio Code,
    \item l'outil de versioning git,
    \item un SGBD (Système de Gestion de Base de Données), %\cite{}
    \item le language PHP,
    \item l'outil Composer,
    \item le framework Laravel,
    \item l'environement d'exécution (runtime environment) Node.js,
    \item le framework Vue.js.
\end{itemize}
Comme vous pouvez le voir, la liste devient vite longue et certains des outils à installer prennent passablement de temps et possèdent des configuration spécifiques.\newline
Je parle notamment des outils suivants:
\begin{itemize}
    \item le SGBD (Système de Gestion de Base de Données),
    \item le language PHP, avec Composer et le framework Laravel,
    \item l'environement d'exécution (runtime environment) Node.js et le framework Vue.js.
\end{itemize}
Ces outils n'étant pas triviaux à mettre en place et changeant pour chaque projet, il est préférable de simplifier le plus possible leur installation et configuration.

Comme vous l'aurez compris, un des besoins le plus important pour le choix de cette infrastructure, est la simplicité de mise en place du projet.\newline
Il faut que cela soit facile à prendre en main et bien documenté.\newline
Un des autres points à prendre en compte, est la disponibilité des outils utilisés, dans le sens où des outils payants ne pourraient pas être accessibles pour certains développeur.\newline
Créer quelque chose de simple à prendre en main, c'est important, mais il faut aussi prendre en compte la difficulté nécessaire pour mettre en place les outils facilitant la prise en main, par exemple Docker.

\subsubsection{Besoins pour l'infrastructure de production}
Nous allons maintenant faire de même pour l'infrastructure de production.\newline
L'infrastructure de production englobe tous les outils à installer et toutes les configurations à réaliser sur un pc vierge afin que le programme final soit accessible est utilisable par n'importe quel utilisateur.\newline
En général, la simplicité de mise à jour du programme, la performance et la robustesse sont recherchés.\newline
On peut aussi prendre en compte la flexibilité de la solution, dans le sens où il serait facile de déployer le programme final sur une autre machine de production.\newline
En effet, la première étape de configuration se réalise peu de fois et si cette dernière est un peu plus compliquée, cela n'est pas forcément un énorme désavantage.\newline
Dans notre cas, pour que le programme puisse fonctionner sur le serveur de production, il est nécessaire d'installer tous les outils suivants:
\begin{itemize}
    \item potentiellement l'outil de versioning git,
    \item un SGBD (Système de Gestion de Base de Données),
    \item le language PHP,
    \item l'outil Composer,
    \item le framework Laravel,
    \item Un serveur Apache,
    \item Un proxy.
\end{itemize}
La liste des outils à installer et configurer, comme pour l'environnement de développement, est conséquente.\newline
Certains outils prennent passablement de temps et possèdent des configuration spécifique.\newline
Je parle notamment des outils suivants:
\begin{itemize}
    \item le SGBD (Système de Gestion de Base de Données),
    \item le language PHP, avec Composer et le framework Laravel.
\end{itemize}
Comme expliqué précédemment, une certaine flexibilité et simplicité est recherchée lors de la mise en place de l'infrastructure et c'est pour cela qu'il est préférable de simplifier le plus possible l'installation et la configuration des outils cités ci-dessus.

Si nous résumons les critères qui influenceront notre décision, nous pouvons ressortir ces derniers:
\begin{itemize}
    \item la performance de l'infrastructure,
    \item la simplicité de mise à jour du programme au sein de l'infrastructure,
    \item la robustesse de l'infrastructure,
    \item la flexibilité de l'infrastructure.
\end{itemize}

\subsubsection{Besoins pour les Devops}
Pour finir, nous allons maintenant faire de même pour le pipeline \Gls{devops}.
Le pipeline \Gls{devops} défini toutes les étapes réalisées et les outils utilisé pour parvenir à mettre en place une infrastructure de travail et de livraison de produit fonctionnel et automatisée au maximum.\newline
Le but des \Gls{devops} étant d'automatisé le plus de tâches possibles, on attend du donc du pipeline les critères suivants:
\begin{itemize}
    \item la performance de l'infrastructure (dans le sens de la rapidité),
    \item la "simplicité" de mise en place du pipeline,
    \item la simplicité de mise à jour du pipeline via une flexibilité maximum,
    \item la robustesse du pipeline,
    \item la possibilité d'ajouter des étapes intermédiaires de tests du produit entre l'infrastructure de développement et de prodution.
\end{itemize}

La flexibilité et simplicité ressort encore une fois dans les besoins de cette section.
Mais un point important est la possibilité de tester manuellement son produit avant de le livrer en production.

\subsubsection{Importance de l'open source et de la gratuité des outils}
Pour tous les choix technologiques qui vont être réaliser, un besoin essentiel intervient.
Plus nous utilisons d'outils open source ou gratuit, plus nous faciliterons l'intégration de n'importe quel développeur au projet.\newline
Mais utiliser des outils qui sont gratuits ou open source offre également un plus pour l'intégration aux DevOps car il facilitera de façon non négligeable la mise en place de ces derniers.

% docker
\subsection{Introduction à Docker}
Pour pour pouvoir comparer les différentes infrastructures et faire des choix sur ces dernière, il est important d'introduire l'outil \Gls{docker}.\newline
Docker est un outil permettant de gérer des conteneurs.\newline
Qu'est-ce qu'un conteneur? Un \Gls{conteneur} est une sorte de machine virtuelle plus légère ayant pour but d'encapsuler une ou plusieurs applications / outils technologiques ainsi que toutes les dépendances que ces applications exigent pour leur bon fonctionnement.\newline
Il ne s'agit donc pas de virtualisation mais de "conteneurisation" ou "containerization" en anglais.
Dans une "conteneurisation", seul l'\Gls{os} et le software est virtualisé et non le hardware.\newline
Nous remarquons bien la différence avec la figure suivante \ref{docker-compare}

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/docker-containerized-and-vm.png}
        \caption[Comparaison Docker vs VM]{Comparaison entre containeurs docker et machines virtuelles
            du \href{https://www.docker.com/wp-content/uploads/2021/11/}{site docker}
            \label{docker-compare}}
    \end{figure}
\end{center}

Les containers sont facilement téléchargeables et transmissibles. Ils sont également relativement facile à mettre en place.\newline
Le principe est simple, nous avons une application et une certaine configuration qui fonctionne, nous pouvons facilement l'encapsuler dans un container et le transmettre à nos collègues ou le télécharger sur un autre pc.\newline
Un des principales avantages, est le fait que le container ne dépend pas de l'OS ou de l'état de la machine sur lequel il va être lancé.\newline
Le seul point requis, est de posséder docker sur la machine.\newline
Cette solution rend plus flexible et portable l'exécution d'application sur n'importe quelle machine.\newline
Voici un schéma démontrant la façon dont docker et des containers dockers sont mis en place sur une
machine comme illustré sur la figure \ref{docker-container-app}.

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/container-what-is-container.png}
        \caption[Conteneurisation d'applications]{Conteneurisation d'applications via
            le \href{https://www.docker.com/wp-content/uploads/2021/11/container-what-is-container.png}{site docker}
            \label{docker-container-app}}
    \end{figure}
\end{center}

%https://www.docker.com/resources/what-container/
%https://www.ibm.com/fr-fr/cloud/learn/docker
%https://fr.wikipedia.org/wiki/Docker_(logiciel)
%https://www.youtube.com/watch?v=Gjnup-PuquQ

Voici une liste des avantages généraux de Docker comparé à une VM:
\begin{itemize}
    \item Les containers sont petits comparé au VM \cite{koukia,nick}, %\char{2713}
    \item Les containers utilisent moins de ressources \cite{koukia},
    \item Les containers démarrent plus rapidement \cite{koukia},
    \item Fonctionne bien avec les DevOps et les CI/CD \cite{koukia,data-flair-pros-cons,data-flair-use-cases},
    \item Facilite l'extensibilité horizontale \cite{data-flair-use-cases},
    \item Regroupe les applications et les fichiers système en une seule image standardisée \cite{kane2018docker},
    \item Permet de tester et livrer l'exact même artefact à tous les systèmes et dans tous les
          environnements \cite{kane2018docker,nick},
    \item Créer une abstraction autour de l'application sans sacrifier trop de ressources \cite{kane2018docker}.
\end{itemize}

Voici une liste des inconvénients de Docker comparé à une VM:
\begin{itemize}
    \item La sécurité, \cite{koukia}
    \item L'isolation non complète', \cite{koukia}
    \item La gestion du réseau. \cite{koukia}
\end{itemize}

\subsubsection{Docker point de vue sécurité}
En ce qui concerne la sécurité de Docker, je ne me suis plongé assez dedans pour ressortir une
analyse concrète et fiable mais j'ai trouvé un article qui en parle. \cite{combe}

% Packaging software in a way that leverages the skills developers already have. \cite{kane2018docker}
% Bundling application software and required OS filesystems together in a single standar‐dized image format. \cite{kane2018docker}
% Using packaged artifacts to test and deliver the exact same artifact to all systems in all environments. \cite{kane2018docker}
% Abstracting software applications from the hardware without sacrificing resources \cite{kane2018docker}

On peut voir sur la figure \ref{docker-use-cases} une liste des cas d'utilisations de docker \cite{data-flair-use-cases}.

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/docker-use-cases.jpg}
        \caption[Cas d'utilisation de docker]{Cas d'utilisation de docker via \href{https://data-flair.training/blogs/wp-content/uploads/sites/2/2018/10/}{data falir}
            \label{docker-use-cases}}
    \end{figure}
\end{center}

% quand ne pas utiliser docker: Performance is critical to your application

%virtual machine vs containers:
%https://www.youtube.com/watch?v=cjXI-yxqGTI
%https://www.ibm.com/cloud/learn/containers?utm_medium=OSocial&utm_source=Youtube&utm_content=000023UA&utm_term=10010608&utm_id=YTDescription-101-Containers-vs-VMs-LH-Containers-Guide&cm_mmc=OSocial_Youtube-_-Cloud+and+Data+Platform_SFT+Cloud+Platform+Digital-_-WW_WW-_-YTDescription-101-Containers-vs-VMs-LH-Containers-Guide&cm_mmca1=000023UA&cm_mmca2=10010608
%https://www.ibm.com/cloud/learn/virtual-machines?utm_medium=OSocial&utm_source=Youtube&utm_content=000005UJ&utm_term=10002434&utm_id=YTDescription-101-Containers-vs-VMs-LH-Virtual-Machines-Guide&cm_mmc=OSocial_Youtube-_-Cloud+and+Data+Platform_PLT+Cloud+Platform+F2F-_-WW_WW-_-YTDescription-101-Containers-vs-VMs-LH-Virtual-Machines-Guide&cm_mmca1=000005UJ&cm_mmca2=10002434


\subsubsection{Performances de Docker}
Docker est outil qui paraît très pratique, mais qu'en est-il de ses performances?
Pour ceci, nous allons retracer quelques évalutations réalisées lors d'une étude de IBM. Nous allons parcourir ces évalutations via des graphiques, tiré de l'étude, résumants bien les résultats.
Commençant par la latence que peut apporter Docker indiquée sur la figure \ref{network-latency}.

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/docker-perf-latency.png}
        \caption[Docker latence aller-retour du réseau]{Latence aller-retour du réseau (µs) \cite{rad2017introduction} \label{network-latency}}
    \end{figure}
\end{center}

On constate que la latence double, mais nous parlons ici de microsecondes, et de 30 microsecondes supplémentaires, ce qui est en soit assez peu pour de petite infrastructure.

En ce qui concerne le transfert de grosses quantité de données via \gls{tcp}, docker parvient à se
rapprocher des performances d'une machine native, elles n'utilisent donc pas beaucoup plus de cycles
comme illustré dans la figure \ref{tcp-transfer-latency}.

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/docker-perf-transfer-efficiancy.png}
        \caption[Docker efficacité du transfert de masse]{Efficacité du transfert de masse TCP (cycles CPU/octet) \cite{rad2017introduction} \label{tcp-transfer-latency}}
    \end{figure}
\end{center}

Au niveau des écritures, on remarque grâce aux deux graphiques suivants que les performances valent
celles d'un système natif comme le montre les figures \ref{sequential-io} et \ref{random-io}

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/docker-perf-sequential-io.png}
        \caption[Docker débit d'I/O séquentielles]{Débit d'Entrée/Sortie séquentielles (Mo/s) \cite{rad2017introduction} \label{sequential-io}}
    \end{figure}
\end{center}

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/docker-perf-random-io.png}
        \caption[Débit d'I/O aléatoires]{Débit d'Entrée/Sortie aléatoires (IOPS) \cite{rad2017introduction} \label{random-io}}
    \end{figure}
\end{center}

On peut également observer sur la figure \ref{docker-perf-mysql} des performances sur le SGBD MySQL
que nous utilisons pour le projet.

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/docker-perf-mysql.png}
        \caption[Comparaison des perf. Docker sur MySQ]{Comparaison des performances de Docker avec des
            transactions sur MySQL \cite{felter} \label{docker-perf-mysql}}
    \end{figure}
\end{center}

Beaucoup d'autres informations ressortent dans un article étudiant les performances de Docker pour
des applications demandant une grande performance. \cite{chung}
Un point intéressant ressort au niveau de la gestion de la mémoire vive qu'utilise Docker, illustré
sur la figure \ref{docker-perf-ram}.

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/docker-perf-ram.png}
        \caption[Comparaison des perf. Docker sur la RAM]{Comparaison des performances de Docker au
            niveau de l'utilisation de la mémoire vive \cite{chung} \label{docker-perf-ram}}
    \end{figure}
\end{center}

%docker en prod perf:
%https://stackoverflow.com/questions/21691540/how-to-optimize-performance-for-a-docker-container/21707838#21707838
%https://stackoverflow.com/questions/21889053/what-is-the-runtime-performance-cost-of-a-docker-container
%https://dominoweb.draco.res.ibm.com/reports/rc25482.pdf
%https://www.freecodecamp.org/news/7-cases-when-not-to-use-docker/


\subsubsection{Et Kubernetes?}
Pourquoi utiliserions-nous forcément docker sans avoir réfléchi à la possibilité de \Gls{kubernetes}?
Pour commencer, comme indiquer sur le site officiel:
"Kubernetes est un système open-source permettant d'automatiser le déploiement, la mise à l'échelle et la gestion des applications conteneurisées".\newline
Kubernetes n'est donc pas vraiment une alternative à docker, mais peut être plutôt utiliser comme complément à ce dernier.\newline
Comme la partie principale de Kubernetes est de gérer les applications conteneurisées et de simplifier le load balancing, par exemple, il n'est pas forcément utile pour nous d'approfondir les recherches sur le sujet.\newline
En effet, La charge attendu par l'application déployée ne devrait pas dépasser les 100 utilisateurs simultanés. La question du load-balancing est donc écartée, tout comme la mise en place d'un cluster Kubernetes.

% comment mettre en place -> voir avec monsieur Graf / regarder avec des profs
% si question pointu, peuvent être transférer à m. chevallier

%https://kubernetes.io/
%https://www.youtube.com/watch?v=PziYflu8cB8
%docker vs k8s, IBM: https://www.youtube.com/watch?v=2vMEQ5zs1ko
%https://www.ibm.com/cloud/learn/kubernetes?cm_mmc=OSocial_Youtube-_-Hybrid+Cloud_Cloud+Platform+Digital-_-WW_WW-_-KubevsDockerYTDescription&cm_mmca1=000023UA&cm_mmca2=10010608#toc-what-is-ku-nVcfWlWE

%https://stackshare.io/: outil très utile pour faire des comparaisons de technologies

\subsubsection{Autres solutions de conteneurs}
Une question se pose, pourquoi utiliserions-nous forcément Docker alors que d'autres solutions existent?
Pour commencer, voici une liste non exhaustive des solutions alternatives à Docker:
\begin{itemize}
    \item \href{https://fr.wikipedia.org/wiki/BSD_Jail}{BSD Jails},
    \item \href{https://linuxcontainers.org/lxd/}{LXD},
    \item \href{https://linuxcontainers.org/lxc/introduction/}{LXC},
    \item \href{https://docs.oracle.com/cd/E18440_01/doc.111/e18415/chapter_zones.htm#OPCUG426}{Solaris Zones},
    \item \href{https://www.redhat.com/en/topics/containers/what-is-rkt}{RKT}.
\end{itemize}

Le principal problème de ces solutions est le manque de popularité comme on peut le remarquer sur la figure \ref{containers-trends}

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/google-trend-containers-2022.png}
        \caption[Tendances solutions de conteneurs]{Tendances sur les différentes solutions de conteneurs depuis 2004} \label{containers-trends}
    \end{figure}
\end{center}


représentant les recherches sur concernant les différents sujets via l'outil \href{https://trends.google.fr/trends}{Google trends}.\newline
Le fait de ne pas être populaire est un gros désavantage pour ces solutions car très peu d'informations, de tutoriels et de documentations sont disponibles sur internet.\newline
Ce simple fait suffit à orienté le choix de la solution de conteneur sur Docker.\newline
N'ayant également pas le temps d'analyser chaque solution en profondeur dans ce travail, cela conforte mon choix.

% dev
\subsection{Infrastructures de développement}

\subsubsection{Présentation des infrastructures de développement possibles}
L'infrastructure que vous pouvez voir dans la figure ci-dessous et celle qui était utilisée lorsque j'ai reprise le projet.\newline
En résumé, tous les outils ont été installés nativement sur la machine de développement sans virtualisation. %\ref
\figi[Infra. dev. actuelle]{infrastructure-dev-actuelle.drawio}{18cm}{Infrastructure de développement actuelle}

\figi[Infra. dev. avec DB en Docker]{infrastructure-dev-db-docker.drawio}{16cm}{Infrastructure de développement avec une DB en Docker}

\figi[Infra. dev. avec DB + Laravel en Docker]{infrastructure-dev-db-laravel-docker.drawio}{16cm}{Infrastructure de développement avec une DB et Laravel en Docker}

Laravel \href{https://laravel.com/docs/9.x/homestead}{Homestead} est un environnement de développement virtualisé à l'aide d'une machine virtuelle \href{https://www.vagrantup.com/}{Vagrant}.\newline
Cette solution est considérée comme le prédecesseur à Laravel Sail qui est beaucoup plus léger.\newline
C'est pourquoi, cette solution ne fera pas parti des choix que nous allons argumenter, mais est présentée comme complément.
\figi[Infra. dev. avec Homestead]{infrastructure-dev-laravel-homestead.drawio}{16cm}{Infrastructure de développement avec Laravel Homestead}

\figi[Infra. dev. avec DB + Laravel + Vue en Docker]{infrastructure-dev-db-laravel-vuejs-docker.drawio}{16cm}{Infrastructure de développement avec une DB, Laravel et Vue.js en Docker}

%https://laravel.com/docs/9.x/sail
%https://blog.logrocket.com/laravel-and-docker-a-guide-to-using-laravel-sail/
%https://r00t4bl3.com/post/how-to-setup-docker-environment-for-laravel-development
%https://dockerize.io/guides/php-laravel-guide
%https://www.honeybadger.io/blog/laravel-docker-php/

\clearpage

\subsubsection{Évolutions de l'infrastructure de développement possibles}
Les différentes infrastructures désormais présentées, il est nécessaire de les comparer en listant les pour et les contres de chaque changement en prenant comme référentielle l'infrastructure actuelle.\newline
Les 3 améliorations (combinées ou non) proposées sont les suivantes:
\begin{itemize}
    \item Passage du SGBD en machine Docker,
    \item Passage du projet Laravel (et toutes ces technologies) en machine Docker,
    \item Passage du projet Vue.js (et toutes ces technologies) en machine Docker.
\end{itemize}

\subsubsection{Passage du SGBD en conteneur Docker}
Commençons par réfléchir sur le passage du SGBD en conteneur Docker.
% vraiment bien se blinder au niveau des arguments via blog et études, sources écrites
% si on a pas trouvé, on peut dire je ne sais pas, on DOIT dire -> joker ultime
% toucher quelque chose en surface, si je ne connais pas, si point essentiel dans projet, faire un choix + essai -> prototype, démonstration sur expérience
% aussi parlé des charges qui devront être supportées et si c'est possible, nb user final par ex
Pour ceci, nous allons énumérer les avantages et inconvénients d'installer le SGBD nativement.
Ces derniers sont visible avec la table \ref{dev-sgbd-native}

\begin{table}[h]
    \begin{center}
        \caption{SGBD natif \label{dev-sgbd-native}}
        \begin{tabularx}{1.0\textwidth} {X|X}
            Avantages                                                         & Inconvénients                                 \\ \hline
            Gestion de la BD plus facile car le SGB est installé nativement   & Demande du temps pour l'installation          \\
            Le SGBD peut-être déjà installé et peut être utilisée directement & Configuration à réaliser à la main            \\
            Ne nécessite pas Docker                                           & Fort risque d'erreur lors de la configuration \\             & Installation différente pour chaque OS                                \\
        \end{tabularx}
    \end{center}
\end{table}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir le SGBD en conteneur
Docker. Ces derniers sont visible avec la table \ref{dev-sgbd-docker}

\begin{table}[h]
    \begin{center}
        \caption{SGBD en conteneur Docker \label{dev-sgbd-docker}}
        \begin{tabularx}{1.0\textwidth} {X|X}
            Avantages                             & Inconvénients                                                         \\ \hline
            Accélère l'installation de l'environnement de développement,
            \cite{labrecque,data-flair-pros-cons} & Gestion de la BD
            potentiellement plus compliquée                                                                               \\
            Apporte de la cohérence au niveau des technologies utilisées, au sein de l'équipe,
            \cite{labrecque,data-flair-use-cases} & Docker peut avoir des problèmes de performances,
            \cite{labrecque}                                                                                              \\
            Rend le debugging dû aux environnements de développement plus facile,
            \cite{labrecque,koukia}               & Nécessite Docker et les connaissances qui vont avec. \cite{labrecque} \\
            Facilite la configuration, car elle est en gande partie déjà réalisée,
            \cite{data-flair-pros-cons}           &                                                                       \\
            Compatible avec tous les OS           &                                                                       \\
        \end{tabularx}
    \end{center}
\end{table}

Si nous évaluons les deux solutions proposées selon les besoins suivants:
\begin{itemize}
    \item simplicité de mise en place du projet,
    \item la disponibilité des outils utilisés,
    \item la difficulté nécessaire pour mettre en place les outils facilitant la prise en main.
\end{itemize}

On se rend facilement compte que la solution avec Docker est celle qui se rapproche le plus de ces derniers.

\subsubsection{Passage de Laravel en conteneur Docker}
Passons maintenant au passage de l'environnement Laravel en conteneur Docker.\newline
Pour ceci, nous allons énumérer les avantages et inconvénients d'installer nativement cet
environnement. Ces derniers sont visible avec la table \ref{dev-laravel-native}.

\begin{table}[h]
    \begin{center}
        \caption{Laravel natif \label{dev-laravel-native}}
        \begin{tabularx}{1.0\textwidth} {X|X}
            Avantages                         & Inconvénients
            \\ \hline
            (Meilleur performance)            & Peut générer des conflits si plusieurs versions sont présentes \\
            Gestion totale de l'environnement & Impossibilité d'avoir plusieurs versions différentes
            installées                                                                                         \\
                                              & L'installation demande du temps                                \\
                                              & Configuration à faire à la main                                \\
                                              & Fort risque d'erreur lors de la configuration                  \\
                                              & Installation différente pour chaque OS                         \\
        \end{tabularx}
    \end{center}
\end{table}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir l'environnement Laravel en
machine Docker. Ces derniers sont visible avec la table \ref{dev-laravel-docker}.

\begin{table}[h]
    \begin{center}
        \caption{Laravel en conteneur Docker \label{dev-laravel-docker}}
        \begin{tabularx}{1.0\textwidth} {X|X}
            Avantages                                                                                                                 & Inconvénients
            \\ \hline
            Accélère l'installation de l'environnement de développement, \cite{labrecque}                                             &                                                                         \\
            Apporte de la cohérence au niveau des technologies utilisées, au sein de l'équipe, \cite{labrecque, data-flair-use-cases} & \Gls{docker} peut avoir des problèmes de performances, \cite{labrecque} \\
            Rend le debugging dû aux environnements de développement plus facile, \cite{labrecque,koukia}                             & Nécessite Docker et les connaissances qui vont avec. \cite{labrecque}   \\
            Facilite la configuration, car elle est en gande partie déjà réalisée, \cite{data-flair-pros-cons}                        &                                                                         \\
            Compatible avec tous les OS                                                                                               &                                                                         \\
            Existance d'un outil donné par Laravel et conçu pour être utiliser avec \Gls{docker}, il
            s'agit de \href{https://laravel.com/docs/9.x/sail}{Sail}
                                                                                                                                      &                                                                         \\
            Permet d'avoir plusieurs versions installées                                                                              &                                                                         \\
        \end{tabularx}
    \end{center}
\end{table}

Si nous évaluons les deux solutions proposées selon les besoins suivants:
\begin{itemize}
    \item simplicité de mise en place du projet,
    \item la disponibilité des outils utilisés,
    \item la difficulté nécessaire pour mettre en place les outils facilitant la prise en main.
\end{itemize}

On se rend facilement compte que la solution avec Laravel Sail est celle qui se rapproche le plus de ces derniers. Et que encore une fois, la solution contenant du Docker paraît assez adaptée.

%https://laravel.com/docs/9.x/sail
%https://laravel.com/docs/9.x/homestead

\subsubsection{Passage de Vue.js en conteneur Docker}
Finalement, parlons du passage de l'environnement \Gls{vuejs} en conteneur Docker.

Pour ceci, nous allons énumérer les avantages et inconvénients d'installer nativement cet
environnement. Ces derniers sont visible avec la table \ref{dev-vuejs-native}.

\begin{table}[h]
    \begin{center}
        \caption{Vue.js natif \label{dev-vuejs-native}}
        \begin{tabular}{c|c}
            Avantages                                           & Inconvénients                   \\ \hline
            (Meilleur performance)                              & Configuration à faire à la main \\
            \Gls{nodejs} possède un bon gestionnaire de version &                                 \\
            Compatible avec tous les OS                         &                                 \\
            Gestion totale de l'environnement                   &                                 \\
        \end{tabular}
    \end{center}
\end{table}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir l'environnement Laravel en
machine Docker.Ces derniers sont visible avec la table \ref{dev-vuejs-docker}.

\begin{table}[h]
    \begin{center}
        \caption{Vue.js en conteneur Docker \label{dev-vuejs-docker}}
        \begin{tabular}{c|c}
            Avantages                                   & Inconvénients                                       \\ \hline
            Rapide à installer                          & Nécessite Docker et les connaissances qui vont avec \\
            Configuration en gande partie déjà réalisée & Peut-être compliqué à mettre en place               \\
            Compatible avec tous les OS                 &                                                     \\
        \end{tabular}
    \end{center}
\end{table}

Si nous évaluons les deux solutions proposées selon les besoins, désormais bien connus et suivants:
\begin{itemize}
    \item simplicité de mise en place du projet,
    \item la disponibilité des outils utilisés,
    \item la difficulté nécessaire pour mettre en place les outils facilitant la prise en main.
\end{itemize}

On se rend compte que la solution avec Docker n'apporte pas forcément assez d'avanatages comparé à celle proposant l'installation native et cela est principalement dû au bon gestionnaire de paquets \href{https://www.npmjs.com/}{NPM} de Javascript. C'est pourquoi, solution proposant l'installation native sera préférée.

\subsubsection{Résultat de l'analyse}
Suite à cette analyse des outils, la solution la plus adaptée semble être de mettre en place
l'environement de développment illustré sur la figure \ref{env-dev}.

\begin{table}[h]
    \begin{center}
        \caption{Environement de développment choisi \label{env-dev}}
        \begin{tabular}{c|c}
            Outil             & Technologie utilisée             \\ \hline
            SGBD - MySQL      & Docker (inclu dans Laravel Sail) \\
            Frontend - Vue.js & Installation native              \\
            Backend - Laravel & Laravel Sail (Docker)            \\
        \end{tabular}
    \end{center}
\end{table}


Finalement cela correspond à la figure numéro \ref{infrastructure-dev-db-laravel-docker.drawio}.

% prod
\clearpage
\subsection{Infrastructures de production}

\subsubsection{Présentation des infrastructures de production possibles}
L'infrastructure de production que vous pouvez voir dans la figure ci-dessous et celle qui était utilisée lorsque j'ai reprise le projet.\newline
En résumé, tous les outils ont été installés nativement sur la machine de développement sans virtualisation.\newline
\figi{infrastructure-prod-actuelle.drawio}{16cm}{Infrastructure de production actuelle}

Cette figure-ci, montre la première amélioration possible, c'est à dire, de passer le SGBD en container docker.
\figi{infrastructure-prod-db-docker.drawio}{16cm}{Infrastructure de production avec une db en docker}

Cette figure-ci, montre la secondes amélioration possible (mais aussi la première), c'est à dire, de passer l'application web réalisée avec le framework Laravel en container docker.
\figi{infrastructure-prod-db-laravel-docker.drawio}{16cm}{Infrastructure de production avec une db et laravel en docker}

\subsubsection{Évolutions de l'infrastructure de production possibles}
Les différentes infrastructures possibles désormais présentées, il est nécessaire de les comparer en listant les pour et les contres de chaque changement en prenant comme référentielle l'infrastructure actuelle.\newline
Les deux améliorations (combinées ou non) proposées sont les suivantes:
\begin{itemize}
    \item Passage du SGBD en machine Docker,
    \item Passage du projet Laravel (et toutes ces technologies) en machine Docker.
\end{itemize}

\subsubsection{Passage du SGBD en conteneur Docker}
Nous recommençons également par réfléchir sur le passage du SGBD en machine Docker.

Pour ceci, nous allons énumérer les avantages et inconvénients d'installer le SGBD nativement.
Certains peuvent être les mêmes qu'énumérer dans la partie "Infrastructure de
développement". Ces derniers sont visible avec la table \ref{prod-db-native}.

\begin{table}[h]
    \begin{center}
        \caption{SGBD natif \label{prod-db-native}}
        \begin{tabularx}{1.0\textwidth} {X|X}
            Avantages                                                         & Inconvénients                          \\ \hline
            Gestion de la BD plus facile car le SGB est installé nativement   & Demande du temps
            pour l'installation                                                                                        \\
            Sauvegarde aisément réalisable                                    & Configuration à réaliser à la main     \\
            Mise en place d'un service de façon triviale                      &                                        \\
            Le SGBD peut-être déjà installé et peut être utilisée directement & Fort risque
            d'erreur lors de la configuration                                                                          \\
            Ne nécessite pas Docker                                           & Installation différente pour chaque OS \\
        \end{tabularx}
    \end{center}
\end{table}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir le SGBD en machine
Docker. Ces derniers sont visible avec la table \ref{prod-db-docker}.

\begin{table}[h]
    \begin{center}
        \caption{SGBD en conteneur Docker \label{prod-db-docker}}
        \begin{tabularx}{1.0\textwidth} {X|X}
            Avantages                                                & Inconvénients                                                        \\ \hline
            Accélère l'installation de l'environnement de production & Gestion de la BD
            potentiellement plus compliquée                                                                                                 \\
            Facilite la mise à jour de l'environnement de production si l'environnement de
            développement intègre un containeur docker pour le SGBD  & Sauvegarde de la BD
            potentiellement plus compliquée                                                                                                 \\
            Configuration en gande partie déjà réalisée              & Mise en place d'un service non trivial                               \\
            Compatible avec tous les OS                              & Docker peut avoir des problèmes de performances
            \cite{labrecque}                                                                                                                \\
                                                                     & Nécessite Docker et les connaissances qui vont avec \cite{labrecque} \\
        \end{tabularx}
    \end{center}
\end{table}

Si nous évaluons les deux solutions proposées selon les besoins, désormais bien connus et suivants:
\begin{itemize}
    \item la performance de l'infrastructure,
    \item la simplicité de mise à jour du programme au sein de l'infrastructure,
    \item la robustesse de l'infrastructure,
    \item la flexibilité de l'infrastructure.
\end{itemize}

On se rend compte que les deux solutions se valent à peu de chose près. Je choisi donc d'essayer de mettre en place une infrastructure avec Docker en premier temps. Si cela est trop compliqué, l'autre solution étant viable pourra toujours être utilisée.

\subsubsection{Passage de Laravel en conteneur Docker}
Passons maintenant au passage de l'environnement Laravel en conteneur Docker.

Pour ceci, nous allons énumérer les avantages et inconvénients d'installer nativement cet
environnement. Ces derniers sont visible avec la table \ref{prod-laravel-native}.

\begin{table}[h]
    \begin{center}
        \caption{Laravel natif \label{prod-laravel-native}}
        \begin{tabularx}{1.0\textwidth} {X|X}
            Avantages                         & Inconvénients                                             \\ \hline
            (Meilleur performance)            & Mise à jour compliquée si un changement de version à lieu \\
            Gestion totale de l'environnement & L'installation demande du temps                           \\
                                              & Configuration à faire à la main                           \\
                                              & Fort risque d'erreur lors de la configuration             \\
                                              & Installation différente pour chaque OS                    \\
        \end{tabularx}
    \end{center}
\end{table}

Nous allons, maintenant, énumérer les avantages et inconvénients d'avoir l'environnement Laravel
en machine Docker.Ces derniers sont visible avec la table \ref{prod-laravel-docker}.

\begin{table}[h]
    \begin{center}
        \caption{Laravel en conteneur Docker \label{prod-laravel-docker}}
        \begin{tabularx}{1.0\textwidth} {X|X}
            Avantages                                                & Inconvénients                      \\ \hline
            Mise à jour du programme facilitée, dans tous les cas    & Peut laisser des failles de
            sécurité, suivant l'environnement mis en place                                                \\
            Accélère l'installation de l'environnement de production & Mise en place d'un service
            non trivial                                                                                   \\
            Configuration en gande partie déjà réalisée              & Docker peut avoir des problèmes de
            performances, \cite{labrecque}                                                                \\
            Offre une possibilité d'extensibilité horizontale        & Nécessite Docker et les
            connaissances qui vont avec. \cite{labrecque}                                                 \\
            Compatible avec tous les OS                              &                                    \\
        \end{tabularx}
    \end{center}
\end{table}

Si nous évaluons les deux solutions proposées selon les besoins, désormais bien connus et suivants:
\begin{itemize}
    \item la performance de l'infrastructure,
    \item la simplicité de mise à jour du programme au sein de l'infrastructure,
    \item la robustesse de l'infrastructure,
    \item la flexibilité de l'infrastructure.
\end{itemize}

On se rend compte que la solution avec Docker paraît plus adaptée. Cependant, si cela venait à être est trop compliqué, l'autre solution étant viable pourra toujours être utilisée.

% TODO pour le déploiment, regarder pourquoi certains sont parti de docker

\subsubsection{Résultat de l'analyse}
Suite à cette analyse des outils, la solution la plus adaptée semble être de mettre en place
l'environnement de production suivant \ref{env-prod}.

\begin{table}[h]
    \begin{center}
        \caption{Environement de production choisi \label{env-prod}}
        \begin{tabular}{c|c}
            Outil             & Technologie utilisée \\ \hline
            SGBD - MySQL      & Docker               \\
            Backend - Laravel & Docker               \\
        \end{tabular}
    \end{center}
\end{table}

\subsubsection{Analyse de risques}
% comment protéger une infra en prod
% contacter des profs de sécu
% lister ce qu'on va mettre en place
% on est resté en surface, il faudrait investir des experts pour évaluer. (audit par exemple)
% sécurité pas prise en compte dans le projet car pas dans objectif, pas le luxe de rechercher car trop de temps, à mentionner dans le rapport.

L'analyse de risques de l'infrastructure de production est point très important lorsque que l'on publie un logiciel. Cette dernière peut être très complexe et nécessite énormément de connaissances.
Une analyse de risque complète demande une quantité conséquent de travail. L'intervention d'expert dans le domaine, via par exemple, des audits serait une solution pour réaliser cette partie du projet.\newline
L'analyse de risques ne pourra donc pas être réaliser lors de ce projet, pour toutes les raisons énumérées plus haut, mais aussi car ce n'est pas le but principal de ce dernier.\newline
J'ai donc décider d'appliquer tout ce que je connaissais et faire le meilleur travail possible sans aller en profondeur dans le sujet.

% devops
%https://blog.logrocket.com/how-to-create-a-ci-cd-for-a-laravel-application-using-github-actions/

\clearpage
\subsection{Pipeline DevOps}
\subsubsection{Introduction aux Devops}
%https://www.youtube.com/watch?v=scEDHsr3APg
%https://www.padok.fr/blog/devops-tout-savoir
%https://azure.microsoft.com/en-us/overview/what-is-devops/#devops-overview
%https://www.ibm.com/cloud/learn/devops-a-complete-guide
Pour commencer, c'est quoi les DevOps?\newline
Les DevOps c'est un ensemble de processus qui permettent de gérer et faciliter le développement et le déploiement continu de l'application. Cela permet de garantir une meilleur qualité du code et de simplifier l'intégration de ce dernier. C'est-à-dire, si un collaborateur souhaite ajouter sa partie du code au projet, il doit d'abord passer par un système automatisé de contrôle et d'intégration de son code avant de pouvoir l'ajouter. Cette partie est appelée \Gls{ci}.\newline
Les DevOps intègre également tout ce qui est déployement continu et livraison continue (\Gls{cd}).
En pratique, ils intègrent également d'autre aspect, comme la maintenance de l'infrastructure de production et développement, la sécurité des processus et beaucoup d'autres concepts.\newline
Au final c'est un cycle de vie visant à faciliter le développement d'applications en équipe.\newline
Ci-dessous, on peut observer un exemple de lifecycle fourni par IBM selon la figure \ref{devops-lifecycle}.

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/ibm-devops-lifecycle.png}
        \caption[Cycle de vie de développement]{Cycle de vie de développement - IBM} \label{devops-lifecycle}
    \end{figure}
\end{center}


Aucun Devops ou pipeline n'avait été réalisé lors du précédent projet.
Nous avons donc que des propositions, sans solution existante (ce qui était le cas pour d'autres choix).\newline
Avant de présenter chacun des pipeline DevOps proposé, il est nécessaire d'expliquer pourquoi chacun de ces derniers passent par Github, et plus précisément, les Github Actions.

\subsubsection{Pourquoi Github?}
Tout d'abord, il faut comprendre qu'il existe d'autres outil de "gestion" de \Gls{devops}, appelé
aussi services de \Gls{ci} / \Gls{devops}, en voici une liste non exhaustive:
\begin{multicols}{2}
    \begin{itemize}
        \item \href{https://www.jenkins.io/}{Jenkins},
        \item \href{https://www.jetbrains.com/teamcity/}{TeamCity},
        \item \href{https://www.guru99.com/top-20-continuous-integration-tools.html}{CircleCI},
        \item \href{https://www.travis-ci.com/}{Travis-CI},
        \item \href{https://about.gitlab.com/}{GitLab},
        \item \href{https://www.atlassian.com/software/bamboo}{Bamboo},
        \item \href{https://www.gocd.org/}{GoCD},
        \item \href{https://azure.microsoft.com/fr-fr/services/devops/}{Azure DevOps}.
    \end{itemize}
\end{multicols}

Tous ces outils, mise à part GitLab, doivent être installé en plus et configurer pour le projet.\newline
Comme il s'agit d'un projet assez restreint et n'impliquant que peu de personnes, nous cherchons à rester dans une solution simple et donc "all in one".\newline
Nous n'allons donc pas plonger dans les détails de chaque technologie citée plus haut.\newline
Parmi les solutions "all in one", c'est-à-dire qui propose des services de \Gls{ci} / \Gls{devops} et permette le versioning de code, il reste uniquement GitLab et Github comme choix.\newline
Ne souhaitant pas réaliser une profonde analyse sur ces 2 solutions, car les 2 étant souvent considérées comme équivalentes ou interchangeable, ma connaissance de la solution Github est un argument suffisant, selon moi, pour faire pencher la balance en sa faveur.
% Tous les outils CI / CD
%https://katalon.com/resources-center/blog/ci-cd-tools#
%https://www.lambdatest.com/blog/31-best-ci-cd-tools/
%https://www.guru99.com/top-20-continuous-integration-tools.html
%https://stackshare.io/stackups/github-actions-vs-gitlab-ci#pros

\subsubsection{Présentation des pipeline Devops possibles}
Ce premier pipeline possible possède uniquement un intérêt si l'infrastructure de production tourne à l'aide de conteneurs Docker. En effet, le but est de construire l' /les image(s) Docker contenant tout ce qui est nécessaire (configurations, programmes, etc.) au niveau de la machine de développement, puis d'envoyer cette / ces dernière(s) sur un repository d'image, en l'occurence, Dockerhub. Puis de récupérer cette / ces images sur la machine de production et les lancer simplement.
\figi{devops-dockerhub.drawio}{16cm}{DevOps via dockerhub}

Ce second pipeline, passerait par une plateforme appelée Heroku. Heroku permet de déployer son application sur l'un de leur serveur, puis le redéployer sur une machine de production finale.\newline
Cette approche est très intéressante car l'étape intermédiaire permet de tester l'application sur une autre machine que celle de développement et ceci avant de livrer en production.
\figi{devops-heroku.drawio}{16cm}{DevOps via heroku}
%https://devcenter.heroku.com/articles/getting-started-with-laravel

Finalement, le pipeline passant uniquement par Github, est la solution la plus simpliste en terme du nombre de technologies utilisées. Cette dernière repose sur le fait de simplement pousser le code sur Github et de le mettre à jour sur la machine de production via un script qui récupère les données sur le Github.
\figi{devops-github.drawio}{16cm}{DevOps via github}

\subsubsection{Comparaison des pipeline Devops possibles}
Nous allons définir pour chacun des pipeline, les avantages et inconvénients de ces derniers.
Mais pour réaliser cette section, certains prototypes doivent être réalisés, ainsi que des recherches appronfidie sur la mise en oeuvre des différents pipeline.\newline
En effet, n'étant pas expert dans le domaine, et n'ayant pas le temps de le devenir le temps de ce travail, l'un des critères / besoins importants et la facilité de mise ne place du pipeline.

% pipeline docker
Commençons par le pipeline Docker:
\begin{itemize}
    \item x
\end{itemize}

Inconvénients:
\begin{itemize}
    \item x
\end{itemize}

Continuons avec le pipeline Heroku:
\begin{itemize}
    \item x
\end{itemize}

Inconvénients:
\begin{itemize}
    \item x
\end{itemize}

Finissons avec le pipeline Github:
\begin{itemize}
    \item x
\end{itemize}

Inconvénients:
\begin{itemize}
    \item x
\end{itemize}

% TODO reciter besoins et dire solution qui se rapproche le plus

%\clearpage
%\subsection{Système de gestion de base de données}
% postgre vs mysql
%https://www.geeksforgeeks.org/difference-between-mysql-and-postgresql/
%https://www.simplilearn.com/tutorials/sql-tutorial/postgresql-vs-mysql
%https://www.ibm.com/cloud/blog/postgresql-vs-mysql-whats-the-difference
%https://stackshare.io/stackups/mysql-vs-postgresql

% upgrade to laravel 9
%https://laravel.com/docs/9.x/upgrade
%https://github.com/laravel/vonage-notification-channel/blob/3.x/UPGRADE.md

% \begin{center}
%     \begin{figure}
%         \includegraphics[width=\textwidth]{./assets/figures/ea.png}
%         \caption[Stack de technologies]{Stack de technologies utilisées via \href{https://stackshare.io/alecberney/bachelors-thesis \label{stack-tb}}}
%     \end{figure}
% \end{center}

\chapter{Conception et Réalisation de la BD}

Dans toutes les desciptions suivantes, les tirets du bas seront remplacé par des "-" à cause d'un problème de LaTex.

\section{Modèle EA}
Le modèle Entité-Associations est la première étape lors de la conception d'une base de données. Il se rapproche également d'un diagramme de classe classique utiliser pour la POO (programmation orienté objet).\newline
Nous allons décrire chacune des entités et ses relations.\newline
Mais avons ça, voici une légende:\newline
Un rectangle représente une entité et possède son nom dans sa partie supérieur.\newline
Les valeurs textuelles en dessous sont les champs de l'entité. Le champ souligné représente la clé primaire de l'entité, cette dernière doit être unique.\newline
Les traits tiré entre deux entités sont des associations et peuvent se lire dans les deux sens. Les verbes écrits au dessus des traits servent à donner un sens à l'association.\newline
Les symboles et numéros à chaque extrémités des entités indiquent respectivement:
\begin{itemize}
    \item 0 : zéro / aucun,
    \item 1 : un,
    \item 1..* : un ou plusieurs,
    \item * : zéro ou plusieurs.
\end{itemize}

Par exemple, on peut lire l'association "user" - "message", comme ceci:\newline
Un utilisateur peut envoyer zéro ou plusieurs messages.\newline
Un message peut être envoyé que par un utilisateur.

Finalement, certains peuvent être ajouté avec des rectangles pliés en haut à droite et relié avec des traits pointillés.

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/ea.png}
        \caption{Modèle EA \label{ea}}
    \end{figure}
\end{center}

\subsection{Entité user}
L'entité "user" représente un utilisateur de l'application, que ce soit un élève, un professeur ou un technicien.\newline
Il possède des informations classiques le concernant, ainsi que le champ "switch-uuid" représentant l'identifiant unique fourni par le service Switch edu-id qui sera utilisé.\newline
Les champs contenant le mot "notify" servent à stocker les préférences de l'utilisateur concernant les notifications de l'application.

On voit au niveau des relations, que l'utilisateur peut envoyer et recevoir des messages.\newline
Il peut posséder également plusieurs rôles mais doit en posséder au moins un, celui par défaut qui est le rôle "client".\newline
L'utilisateur peut de toute façon faire une demande de travail (job). Cependant, seul les utilisateurs possédant le rôle "validator", en général, les professeurs pourront valider le travail.\newline
Le travail validé, un "worker", en général un technicien, pourra réaliser le travail demander et en indiquer le suivi.

\subsection{Entité job}
L'entité "job" représente un travail demandé par un utilisateur de l'application.\newline
Il possède un id (identifiant unique), une description du travail à réaliser, une date butoir (deadline), une évaluation que l'utilisateur / client peut attribuer au travail terminé et un status d'avancement du travail mis à jour par le travailleur.\newline
Le status d'avancement d'un travail sera défini par un enum (liste exhaustive de valeurs), la voici:
\begin{itemize}
    \item new,
    \item validated,
    \item assigned,
    \item ongoing,
    \item on-hold,
    \item completed.
\end{itemize}

On voit au niveau des relations, que le travail peut posséder des messages qui lui sont liés.\newline
Il posséde également une catégorie de travail définissant ensuite quelles machines peuvent être utilisées pour le réaliser.\newline
Le travail possédera également un utilisateur client, un validateur et un travailleur.\newline
Il doit également contenir un ou plusieurs fichiers nécessaires pour réaliser le travail demandé.\newline
Finalement, certains événements peuvent être lié au travail. On parle ici d'événement permettant de préfevenir l'utilisateur via des notifications ou email.

\subsection{Entité role}
L'entité "role" représente simplement un rôle que peut avoir un utilisateur au sein de l'application. Cette entité est nécessaire car un utilisateur peut posséder plusieurs rôles et ils doivent tous être défini la même chose.\newline
Seul un id (identifiant unique) et un nom du rôle est nécessaire.\newline
Voici la liste des rôles définis:
\begin{itemize}
    \item admin,
    \item client,
    \item worker,
    \item validator.
\end{itemize}

\subsection{Entité message}
L'entité "message" représente un message envoyé entre deux utilisateurs au sujet d'un travail demandé.\newline
Il possède uniquement un id (identifiant unique) et un text.\newline
Il est associé à deux utilisateurs, un représentant celui qui a envoyé le message et l'autre celui qu'il l'a reçu. Le message est également associé au travail dont il est le sujet.\newline
Une aggrégation a été modélisé pour cette dernière association car on souhaite supprimé tous les messages liés à un travail, si ce dernier est supprimé.

\subsection{Entité job-category}
L'entité "job-category" représente une catégorie de travail pouvant être effecutée au fablab, pare exemple, une impression 3D ou une découpe laser.\newline
La catégorie possède un id (identifiant unique), un acronyme et un nom.\newline
Elle est associé à un travail car ce dernier est obligé d'avoir une catégorie.\newline
Elle possède également une ou plusieurs machines (device) sur lesquels peuvent être réaliser les travaux.\newline
Comme elle possède des machines, une liste de type de fichiers acceptés est nécessaire et est défini par l'association "job-category" - "file-type". Cela permettra de facilement vérifier si un fichier donné pour un travail peut être accepté pour la catégorie de ce dernier.

\subsection{Entité device}
L'entité "device" représente une machine / un outil utilisé pour réaliser un travail du fablab.\newline
La machine possède un id (identifiant unique), un nom, une description plus précise et un chemin de fichier où est stocké son image (cette partie pourrait changer).\newline
Comme expliqué précédement dans la catégorie, elle possède une ou plusieurs catégories sur lesquels elle peut être utilisée.\newline

\subsection{Entité file-type}
L'entité "file-type" représente un type de fichier que peut accepter une catégorie de travail du fablab.\newline
Le type de fichier possède un id (identifiant unique), un nom et un mime-type \href{https://developer.mozilla.org/fr/docs/Web/HTTP/Basics_of_HTTP/MIME_Types} étant utiliser pour valider les fichiers télécharger.\newline
Comme expliqué précédement dans la catégorie, un type de fichier possède une ou plusieurs catégories qui sont acceptées.\newline
Le type de fichier peut également être associé à plusieurs fichiers.

\subsection{Entité file}
L'entité "file" représente un fichier fourni pour réaliser un travail du fablab.\newline
Le fichier possède un id (identifiant unique), un nom et un hash de son contenu.\newline
Il est associé à un type de fichier (file-type), ce qui est utile pour faire le lien avec la catégorie du travail.\newline
Il possède évidemment un travail pour indiquer pour auquel il appartient.\newline
Une aggrégation a été modélisé pour cette dernière association car on souhaite supprimé tous les fichiers liés à un travail, si ce dernier est supprimé.

\subsection{Entité event}
L'entité "event" représente un événement concernant un travail du fablab. Par exemple, un événement est généré si le status d'un travail a été modifié ou si un fichier a été ajouté.\newline
L'événement possède un id (identifiant unique) et des données (data).\newline
Il est associé à un travail comme expliqué plus précédement.\newline
Une aggrégation a été modélisé pour cette dernière association car on souhaite supprimé tous les événements liés à un travail, si ce dernier est supprimé.

\subsection{Entité tasks-queue et failed-tasks}
Ces entités ont été modélisées pour effectuer les tâches en arrière plan du backend, comme l'envoi d'email retardé. Elle ne sont pas encore très développée par manque de connaissances de leur fonctionnement.

\section{MLD}
Le modèle logique des données n'est rien d'autre qu'une évolution du modèle EA.\newline
Les entités deviennent des tables et les associations des relations, ce qui est presque la même chose.\newline
Les tables ont pris un nom au pluriel pour respecter la philosophie de Laravel et de son ORM Eloquent.\newline
Les champs obtiennent des types représentant la façon dont ils seront stockés.\newline
Les clés étrangère issues des association s'ajoutent aux tables.\newline
Les associations N à N du modèle EA voient naître une table intermédiaire. Voici celles qui ont été créées:
\begin{itemize}
    \item device-job-category,
    \item file-type-job-category,
    \item role-user.
\end{itemize}

\begin{center}
    \begin{figure}
        \includegraphics[width=\textwidth]{./assets/figures/mld.png}
        \caption{Modèle Logique des données \label{mld}}
    \end{figure}
\end{center}

Sur le schéma, quelques nouveaux symboles apparaîssent, voici une légende:
\begin{itemize}
    \item Clé jaune : clé primaire de la ligne,
    \item Losange bleu : la colonne ne peut pas valoir null,
    \item Losange vide : la colonne peut valoir null,
    \item Losange rouge : la colonne possède une clé étrangère.
\end{itemize}

Une clé étrangère étant le champ représantant une autre table dont une relation existe. La clé primaire représente la table en elle-même, elle est son identifiant.

\subsection{Champs spéciaux}
Quelques champs obtiennet des valeurs précises et méritent une explication.\newline
Les champs switch-uuid et email, de la table "users" possèdent 320 charactères car ils sont tous des emails ou des dérivés et une email peut contenir au maximum 320 charactères.

Le champ status de la table "job" est une enum comme expliqué précédement dans le modèle EA.

\subsection{Remarques}
% TODO une fois défini
Tous les autres champs n'ont pas encore fait l'objet de recherches ou de spécifications et ont donc souvent une valeur de 45 ou 50 charactères. Cela cera réalisé prochainement.

Les entités concernant les tâches en arrière plan n'apparaîssent pas car elle ne sont pas encore assez connue.

%Certaines colonnes sont communes à plusieurs des tables. C'est le cas de 'created_at',
%qui indique l'heure de création de la ligne, et 'updated_at', qui indique l’heure à
%laquelle la ligne à été modifiée pour la dernière fois.


\section{Migrations Laravel}

Les migrations du backend réalisées avec Laravel et l'ORM Eloquent se rapprochent le plus possibles du MLD présenté précédement.

\subsection{Types de champs}
Voici une liste des types possibles et utilisées:
\begin{itemize}
    \item id représentant un entier positif incrémentable, unique, indiqué comme clé primaire et référencé via un index,
    \item string représentant une chaîne de caractères,
    \item longText représentant un grand texte,
    \item enum représentant une liste exhaustive de valeurs possibles,
    \item tinyInteger représentant un petit entier,
    \item date représentant une date.
\end{itemize}

La liste plus complète peut être consultée dans la doc \href{https://laravel.com/docs/9.x/migrations#available-column-types}{Laravel}.

\begin{listing}[h]
    \inputminted{php}{assets/code/11_create_devices_table.php}
    \caption{Migration de la table "devices" \label{migrations-devices}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/12_create_file_types_table.php}
    \caption{Migration de la table "file-types" \label{migrations-file-types}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/13_create_roles_table.php}
    \caption{Migration de la table "roles" \label{migrations-roles}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/14_create_users_table.php}
    \caption{Migration de la table "users" \label{migrations-users}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/15_create_job_categories_table.php}
    \caption{Migration de la table "job-categories" \label{migrations-job-categories}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/16_create_jobs_table.php}
    \caption{Migration de la table "jobs" \label{migrations-jobs}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/17_create_events_table.php}
    \caption{Migration de la table "events" \label{migrations-events}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/18_create_files_table.php}
    \caption{Migration de la table "files" \label{migrations-files}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/19_create_messages_table.php}
    \caption{Migration de la table "messages" \label{migrations-messages}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/20_create_device_job_category_table.php}
    \caption{Migration de la table "device-job-category" \label{migrations-device-job-category}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/21_create_file_type_job_category_table.php}
    \caption{Migration de la table "file-type-job-category" \label{migrations-file-type-job-category}}
\end{listing}

\begin{listing}[h]
    \inputminted{php}{assets/code/22_create_role_user_table.php}
    \caption{Migration de la table "role-user" \label{migrations-role-user}}
\end{listing}

\subsection{Champs possiblement "null"}
La possibilité de laisser une valeur nulle sur un champ n'apparaît pas sur le MLD, mais est bien présente au niveau des migrations et modèles de Laravel.\newline
Tous ces champs possèdent l'indiquation: "->nullable()".\newline
Seul certains champs peuvent être "null" dans notre base de données et ceux-ci interviennent surtout dans la table "jobs".\newline
Les champs qui peuvent être "null" sont des champs dont la valeur n'est pas obligatoirement présente à la création mais peut-être ajoutée plus tard. Il s'agit par exemple de la note donnée au travail "rating" ou encore le technicien devant effectuer ce dernier qui peut être assigné après coup.

\subsection{Champs uniques}
Il est possible d'indiquer qu'un champ doit posséder une valeur unique avec l'option: "->unique()".\newline
Cette possibilité est par exemple utilisée par le champ email.

\subsection{Champs timestamps}
Les champs de type "->timestamps()" sont un raccourci utilisé par Laravel pour créer deux champs indiquant la date de création de la donnée et la date de modification. Ces champs sont gérés automatiquement par Laravel, ce qui est bien pratique.

\subsection{Indexes}
Il est possible de créer des indexes sur certains champs afin d'améliorer les performances de la base de données lors de certaines requêtes. Ces indexes peuvent être créer grâce à l'instruction "index('table-champ')".\newline
Ces derniers sont toujours créer sur les clés primaires et doivent être créer sur les clés étrangères. D'autres champs régulièrement utilisés par des requêtes peuvent faire l'objet d'indexes.

\subsection{Clés étrangères}
Les clés étrangères peuvent être gérées de deux façon différentes.\newline
Soit on ajoute un champ "foreignId('table-id')" suivi d'un "->constrained('table')" qui permet de faire le lien directe entre la clé primaire et la clé étrangère tout en générant un index. Mais ceci est possible uniquement si l'on utilise une clé primaire de type "id()".

Dans le deuxième cas, lorsque l'on possède une clé primaire basée sur un autre type de champ, il faut tout d'abord cr��er un champ à la main avec la valeur voulue.\newline
Puis faire le lien entre la clé primaire et étrangère à la main en utilisant d'abord "->foreign('table-champ')", puis en référançant avec "->references('champ')->on('table')".\newline
Puis, finalement, créer un index avec "index('table-champ')" sur le champ de la clé étrangère.

\subsection{Options de suppression}
Des options de suppression sont proposées par Eloquent afin de ne pas supprimer définitivement les données de la base de données, mais de simplement les désactiver afin quelles n'apparaîssent plus dans les requêtes.\newline
Ceci est possible en ajoutant l'option "->softDeletes()" à la table.\newline
Laravel s'occupera ensuite de gérer les cas de suppression lui-même.

\chapter{Conception et Réalisation du Backend / de l'API}
%todo à rendre aussi pour le premier rendu
%todo architecture de code
\section{Architectures de code}

\figi{architecture-code-spring.drawio}{16cm}{Architecture de code du framework Spring "classique"}

\figi{architecture-code-laravel.drawio}{16cm}{Architecture de code du framework Laravel "classique"}

\figi{architecture-code-laravel-proposee.drawio}{16cm}{Architecture de code Laravel proposée}

% ensuite décrire ce qu'on a mis en place et indiquer s'il y a des failles

% surtout indiquer tout ce qu'on a fait et tout ce que j'ai pas fait
% et pourquoi je l'ai pas fait, pas compris qqch ou pas eu le temps, pas la priorité, pas de sources suffisantes

%dans le texte (Labrecque, 2018)
%\cite{labrecque}

%suivantes:
%(Labrecque, 2018; x, yyyy;)
%pour reformuler

%Labrecque M. (2018). Pros and cons of Docker. in \textit{Docker, planet drupal}. consulté à %l'adresse: https://affinitybridge.com/blog/pros-and-cons-docker (consulté le 31.03.2022)

\chapter{Intégration continu}

\chapter{Déploiement continu}

\chapter{Reprise du projet}

\section{Récupération physique du projet}

\section{Erreurs restantes}

\section{Améliorations possibles}

%%if
\chapter{Bibliographie}
\section{Citations et bibliographie}
%Citer vos sources est essentiel. Avec \texttt{biblatex} vous pouvez facilement citer des articles, des livres ou des sites internet. Toutes les citations dans le texte seront automatiquement regroupées en fin de document dans la section \guillemotleft Bibliographie\guillemotright. Par exemple, citons un article d'Einstein \cite{einstein} ou le livre de Dirac \cite{dirac}.

%Parfois il peut être utile d'utiliser un gestionnaire de bibliographie. La communauté académique recommande l'outil \href{https://www.zotero.org/}{Zotero} qui permet de gérer une bibliothèque numérique d'ouvrages et de références numériques. Il permet également de générer une bibliographie compatible avec \LaTeX.


%\mintinline{latex}{\SI{42.12}{\kilo\gram\metre\per\square\second}}\par
%%fi

\chapter{Conclusion}

%%if
%Bien que non nécessaire dans un rapport de Bachelor, la discussion finale d'un projet résume les résultats obtenus et dresse une conclusion objective du projet. Un manager de société est souvent amené à lire de nombreux rapport, il ne s'intéresse généralement qu'à l'introduction au contexte de l'étude et à sa conclusion.

%Il est de coutume de signer la conclusion...
%%fi

\section{Sources d'informations}
Lors d'un projet de développement informatique, beraucoup de recherches sont réalisées lors de la
phase de développement. Il est impossible de citer toutes les sources utilisées, mais il est
important de citer les forums les plus utilisés, ainsi que les documentations.\newline
Voici donc une liste de références:

\begin{itemize}
    \item laravel.com : documentation de Laravel \cite{laravel},
    \item stackoverflow.com : forum mondial numéro un pour les programmeurs \cite{stackoverflow},
    \item w3schools.com : documentation et exemples pour HTML, CSS et JavaScript \cite{w3schools},
    \item digitalocean.com : Tutoriels, pour Docker, Apache et Ubuntu \cite{digitalocean},
    \item switch.ch : toute la procédure pour l’utilisation de Shibboleth et Switch edu-id \cite{switch},
    \item stackshare.io : outil pour comparer des technologies ou utils \cite{stackshare},
    \item wikipedia.org: site d'informations.
\end{itemize}

\vfil
\hspace{8cm}\makeatletter\@author\makeatother\par
\hspace{8cm}\begin{minipage}{5cm}
    %%if
    % Place pour signature numérique
    \printsignature
    %%fi
\end{minipage}
\clearpage

\appendix
\appendixpage
\addappheadtotoc

%%if
\chapter{Planning}

\begin{landscape}
    \includepdf{./assets/annexes/planning.pdf}
\end{landscape}

%Les annexes n'ont pas un contenu \underline{normatif} mais \underline{descriptif}. Tout contenu annexé ne doit pas être nécessaire à la bonne compréhension du travail.

%Les annexes contiennent généralement :

%\begin{itemize}
%    \item les dessins mécaniques (mises en plan);
%    \item les schémas électriques détaillés;
%    \item des photographies du projet;
%    \item des scripts et des extraits de code source;
%    \item des documents techniques \pex \emph{datasheet};
%    \item des développements mathématiques.
%\end{itemize}
%\section{Sous section}
%\lipsum[1]
%%fi

\let\cleardoublepage\clearpage
\backmatter

\label{glossaire}
\printnoidxglossary
\printbibliography
\label{index}
\printindex

\end{document}
